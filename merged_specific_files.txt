# --------------- START OF FILE: backend/main.py ---------------

# backend/main.py

import os
import pandas as pd
from contextlib import asynccontextmanager
import tempfile
from fastapi import BackgroundTasks
from pydantic import ValidationError
from fastapi import FastAPI, Depends, HTTPException, status, UploadFile, File, Query, Form, Request, Response, Body
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse, JSONResponse
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
import io
from datetime import datetime, timezone
import crud, models, schemas, auth
from database import SessionLocal, engine, get_db
from typing import Optional, List
import ocr_service 
from celery.result import AsyncResult
from celery_worker import celery_app, extract_document_data
import logging 

from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
from dotenv import load_dotenv

# Load environment variables from a .env file (for local development)
load_dotenv()

# CONFIGURE logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# INITIALIZE the limiter to identify users by their IP address
limiter = Limiter(key_func=get_remote_address)


# --- CORRECT STARTUP LOGIC ---
# Define UPLOAD_DIR here so it's accessible globally
UPLOAD_DIR = "uploads"

# Lifespan manager to handle startup events like creating directories.
@asynccontextmanager
async def lifespan(app: FastAPI):
    # This code runs once on application startup.
    logger.info("Application startup...")
    # Create the upload directory, but don't fail if it already exists.
    os.makedirs(UPLOAD_DIR, exist_ok=True)
    logger.info(f"Ensured upload directory '{UPLOAD_DIR}' exists.")
    
    yield
    
    # This code runs on shutdown.
    logger.info("Application shutdown.")


app = FastAPI(lifespan=lifespan)

# SET the limiter on the app state and add the exception handler
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)


# --- CORS Middleware ---
origins = ["*"]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
    expose_headers=["Content-Disposition"],
)

# --- Authentication Routes ---
@app.post("/token", response_model=schemas.Token)
@limiter.limit("5/minute")
def login_for_access_token(request: Request, form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = auth.authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Nom d'utilisateur ou mot de passe incorrect",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token = auth.create_access_token(data={"sub": user.user_name})
    return {"access_token": access_token, "token_type": "bearer"}

# --- User Routes ---
@app.post("/users/", response_model=schemas.User)
def register_user(user: schemas.UserCreate, token: str = Query(...), db: Session = Depends(get_db)):
    invitation = crud.get_invitation_by_token(db, token)
    if not invitation or invitation.is_used or invitation.expires_at.replace(tzinfo=timezone.utc) < datetime.now(timezone.utc):
        raise HTTPException(status_code=400, detail="Jeton d'inscription invalide ou expiré.")

    if invitation.email != user.email:
        raise HTTPException(status_code=400, detail="L'email d'inscription ne correspond pas à l'email de l'invitation.")

    db_user_by_email = crud.get_user_by_email(db, email=user.email)
    if db_user_by_email:
        raise HTTPException(status_code=400, detail="Email déjà enregistré")

    db_user_by_username = crud.get_user_by_username(db, username=user.user_name)
    if db_user_by_username:
        raise HTTPException(status_code=400, detail="Nom d'utilisateur déjà enregistré")

    created_user = crud.create_user(db=db, user=user, role="user")
    
    db.delete(invitation)
    db.commit()

    return created_user

@app.get("/users/me", response_model=schemas.User)
def read_users_me(current_user: models.User = Depends(auth.get_current_active_user)):
    return current_user

@app.put("/users/me", response_model=schemas.User)
def update_user_me(user_update: schemas.UserUpdate, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    return crud.update_user(db=db, user_id=current_user.id, user_update=user_update)

@app.get("/admin/users/", response_model=list[schemas.User], dependencies=[Depends(auth.require_admin)])
def read_users(
    skip: int = 0,
    limit: int = 100,
    name_filter: Optional[str] = Query(None),
    db: Session = Depends(get_db)
):
    users = crud.get_users(db, skip=skip, limit=limit, name_filter=name_filter)
    return users

@app.delete("/admin/users/{user_id}", response_model=schemas.User, dependencies=[Depends(auth.require_admin)])
def delete_user(user_id: int, db: Session = Depends(get_db)):
    db_user = crud.delete_user(db=db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvé")
    return db_user

@app.get("/admin/users/{user_id}", response_model=schemas.User, dependencies=[Depends(auth.require_admin)])
def read_user(user_id: int, db: Session = Depends(get_db)):
    db_user = crud.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvé")
    return db_user

@app.put("/admin/users/{user_id}", response_model=schemas.User, dependencies=[Depends(auth.require_admin)])
def update_user(user_id: int, user_update: schemas.UserUpdate, db: Session = Depends(get_db)):
    db_user = crud.update_user(db=db, user_id=user_id, user_update=user_update)
    if db_user is None:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvé")
    return db_user

@app.post("/admin/users/", response_model=schemas.User, dependencies=[Depends(auth.require_admin)])
def create_user_by_admin(user: schemas.UserCreate, db: Session = Depends(get_db)):
    db_user_by_email = crud.get_user_by_email(db, email=user.email)
    if db_user_by_email:
        raise HTTPException(status_code=400, detail="Email déjà enregistré")

    db_user_by_username = crud.get_user_by_username(db, username=user.user_name)
    if db_user_by_username:
        raise HTTPException(status_code=400, detail="Nom d'utilisateur déjà enregistré")

    return crud.create_user(db=db, user=user, role=user.role if hasattr(user, 'role') else 'user')

# --- Passport Routes ---
@app.post("/passports/", response_model=schemas.Passport)
def create_passport(passport: schemas.PassportCreate, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    return crud.create_user_passport(db=db, passport=passport, user_id=current_user.id)

@app.post("/passports/upload-and-extract/", response_model=schemas.MultiAsyncTaskResponse, status_code=status.HTTP_202_ACCEPTED)
async def upload_and_extract_passport_async(
    destination: Optional[str] = Form(None),
    files: List[UploadFile] = File(...),
    current_user: models.User = Depends(auth.get_current_active_user)
):
    task_ids = []
    for file in files:
        try:
            with tempfile.NamedTemporaryFile(delete=False, suffix=f"-{file.filename}") as temp_file:
                content = await file.read()
                temp_file.write(content)
                temp_file_path = temp_file.name
        except Exception as e:
            logger.error(f"Could not save uploaded file to disk: {file.filename}. Error: {e}")
            continue

        task = extract_document_data.delay(
            file_path=temp_file_path,
            original_filename=file.filename,
            content_type=file.content_type,
            destination=destination,
            user_id=current_user.id
        )
        task_ids.append({"task_id": task.id, "filename": file.filename})

    if not task_ids:
        raise HTTPException(status_code=500, detail="No files could be processed.")

    return JSONResponse(content={"tasks": task_ids}, status_code=status.HTTP_202_ACCEPTED)

@app.get("/tasks/{task_id}/status", response_model=schemas.AsyncTaskStatus)
def get_task_status(task_id: str):
    task_result = AsyncResult(task_id, app=celery_app)
    
    response_data = {
        "task_id": task_id,
        "status": task_result.status,
        "progress": None,
        "result": None
    }
    
    if task_result.status == 'SUCCESS':
        response_data["result"] = task_result.result
    elif task_result.status == 'FAILURE':
        response_data["result"] = str(task_result.info)
    elif task_result.status == 'PROGRESS':
        response_data["progress"] = task_result.info if isinstance(task_result.info, dict) else {"status": str(task_result.info)}
    elif task_result.status == 'REVOKED':
        response_data['status'] = 'CANCELLED'
        response_data['progress'] = {'status': 'Task was cancelled.'}

    return response_data

@app.post("/tasks/{task_id}/cancel", status_code=status.HTTP_202_ACCEPTED)
def cancel_task(task_id: str):
    logger.info(f"Received request to cancel task: {task_id}")
    celery_app.control.revoke(task_id, terminate=True, signal='SIGTERM')
    return JSONResponse(content={"message": "Cancellation request sent."}, status_code=202)

@app.get("/export/data")
def export_data(
    destination: Optional[str] = None,
    user_id: Optional[int] = None,
    first_name: Optional[str] = None,
    last_name: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: models.User = Depends(auth.get_current_active_user)
):
    effective_user_id = current_user.id
    if current_user.role == "admin":
        effective_user_id = user_id
    
    filtered_data = crud.filter_data(db, destination, effective_user_id, first_name, last_name)
    
    if not filtered_data:
        raise HTTPException(status_code=404, detail="Aucune donnée de passeport trouvée pour les critères donnés")
    
    df = pd.DataFrame(filtered_data)
    stream = io.StringIO()
    df.to_csv(stream, index=False)
    
    filename_parts = ["passeports"]
    if destination:
        filename_parts.append(destination.replace(' ', '_').lower())

    if current_user.role == 'admin':
        if user_id:
            filtered_user = crud.get_user(db, user_id)
            if filtered_user:
                filename_parts.append(f"pour_{filtered_user.user_name.lower()}")
            else:
                filename_parts.append(f"pour_utilisateur_{user_id}")
        else:
            filename_parts.append("rapport")
    else:
        filename_parts.append(f"pour_{current_user.user_name.lower()}")

    filename = f"{'_'.join(filename_parts)}.csv"
        
    response = StreamingResponse(iter([stream.getvalue()]), media_type="text/csv")
    response.headers["Content-Disposition"] = f"attachment; filename={filename}"
    return response

@app.get("/passports/", response_model=list[schemas.Passport])
def read_passports(
    db: Session = Depends(get_db),
    current_user: models.User = Depends(auth.get_current_active_user),
    user_filter: Optional[str] = None,
    voyage_filter: Optional[str] = None
):
    if current_user.role == "admin":
        return crud.get_passports(db=db, user_filter=user_filter, voyage_filter=voyage_filter)
    return crud.get_passports_by_user(db=db, user_id=current_user.id)

@app.put("/passports/{passport_id}", response_model=schemas.Passport)
def update_passport(passport_id: int, passport_update: schemas.PassportCreate, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    db_passport = crud.get_passport(db, passport_id=passport_id)
    if db_passport is None:
        raise HTTPException(status_code=404, detail="Passeport non trouvé")
    if current_user.role != "admin" and db_passport.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Non autorisé à mettre à jour ce passeport")
    return crud.update_passport(db=db, passport_id=passport_id, passport_update=passport_update)

@app.delete("/passports/{passport_id}", response_model=schemas.Passport)
def delete_passport(passport_id: int, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    db_passport = crud.get_passport(db, passport_id=passport_id)
    if db_passport is None:
        raise HTTPException(status_code=404, detail="Passeport non trouvé")
    if current_user.role != "admin" and db_passport.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Non autorisé à supprimer ce passeport")
    return crud.delete_passport(db=db, passport_id=passport_id)

@app.post("/passports/delete-multiple", status_code=status.HTTP_204_NO_CONTENT, summary="Delete multiple passports")
def delete_multiple_passports(
    payload: schemas.IdsList = Body(...),
    db: Session = Depends(get_db),
    current_user: models.User = Depends(auth.get_current_active_user)
):
    if not payload.ids:
        return Response(status_code=status.HTTP_204_NO_CONTENT)

    crud.delete_passports_by_ids(
        db=db,
        passport_ids=payload.ids,
        user_id=current_user.id,
        is_admin=(current_user.role == 'admin')
    )
    
    return Response(status_code=status.HTTP_204_NO_CONTENT)

# --- Voyage Routes ---
@app.post("/voyages/", response_model=schemas.Voyage)
def create_voyage(voyage: schemas.VoyageCreate, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    return crud.create_user_voyage(db=db, voyage=voyage, user_id=current_user.id, passport_ids=voyage.passport_ids)

@app.get("/voyages/", response_model=list[schemas.Voyage])
def read_voyages(
    db: Session = Depends(get_db),
    current_user: models.User = Depends(auth.get_current_active_user),
    user_filter: Optional[str] = None
):
    if current_user.role == "admin":
        return crud.get_voyages(db=db, user_filter=user_filter)
    return crud.get_voyages_by_user(db=db, user_id=current_user.id)

@app.put("/voyages/{voyage_id}", response_model=schemas.Voyage)
def update_voyage(voyage_id: int, voyage_update: schemas.VoyageCreate, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    db_voyage = crud.get_voyage(db, voyage_id=voyage_id)
    if db_voyage is None:
        raise HTTPException(status_code=404, detail="Voyage non trouvé")
    if current_user.role != "admin" and db_voyage.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Non autorisé à mettre à jour ce voyage")
    return crud.update_voyage(db=db, voyage_id=voyage_id, voyage_update=voyage_update)

@app.delete("/voyages/{voyage_id}", response_model=schemas.Voyage)
def delete_voyage(voyage_id: int, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    db_voyage = crud.get_voyage(db, voyage_id=voyage_id)
    if db_voyage is None:
        raise HTTPException(status_code=404, detail="Voyage non trouvé")
    if current_user.role != "admin" and db_voyage.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Non autorisé à supprimer ce voyage")
    return crud.delete_voyage(db=db, voyage_id=voyage_id)

@app.get("/destinations/", response_model=List[str])
def get_unique_destinations(
    user_id: Optional[int] = Query(None),
    db: Session = Depends(get_db),
    current_user: models.User = Depends(auth.get_current_active_user)
):
    target_user_id = current_user.id
    if current_user.role == "admin" and user_id is not None:
        target_user_id = user_id
    
    return crud.get_destinations_by_user_id(db, user_id=target_user_id)

# --- File Upload Route ---
@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile = File(...), current_user: models.User = Depends(auth.get_current_active_user)):
    file_location = os.path.join(UPLOAD_DIR, f"{current_user.user_name}_{file.filename}")
    with open(file_location, "wb+") as file_object:
        file_object.write(file.file.read())
    return {"info": f"fichier '{file.filename}' sauvegardé à '{file_location}'"}

@app.get("/invitations/{token}", response_model=schemas.Invitation)
def get_invitation(token: str, db: Session = Depends(get_db)):
    invitation = crud.get_invitation_by_token(db, token)
    if not invitation or invitation.is_used or invitation.expires_at.replace(tzinfo=timezone.utc) < datetime.now(timezone.utc):
        raise HTTPException(status_code=404, detail="Invitation non trouvée ou invalide.")
    return invitation

# --- Admin-specific Routes ---
@app.post("/admin/invitations", response_model=schemas.Invitation, dependencies=[Depends(auth.require_admin)])
def create_invitation(invitation: schemas.InvitationCreate, db: Session = Depends(get_db)):
    existing_user = crud.get_user_by_email(db, email=invitation.email)
    if existing_user:
        raise HTTPException(status_code=400, detail="Un utilisateur avec cet email existe déjà.")

    existing_invitation = crud.get_invitation_by_email(db, email=invitation.email)
    if existing_invitation and not existing_invitation.is_used:
        raise HTTPException(status_code=400, detail="Une invitation active pour cet email existe déjà.")
    
    return crud.create_invitation(db=db, email=invitation.email)

@app.get("/admin/invitations/", response_model=list[schemas.Invitation], dependencies=[Depends(auth.require_admin)])
def read_invitations(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    invitations = crud.get_invitations(db, skip=skip, limit=limit)
    return invitations

@app.put("/admin/invitations/{invitation_id}", response_model=schemas.Invitation, dependencies=[Depends(auth.require_admin)])
def update_invitation(invitation_id: int, invitation_update: schemas.InvitationUpdate, db: Session = Depends(get_db)):
    db_invitation = crud.update_invitation(db=db, invitation_id=invitation_id, invitation_update=invitation_update)
    if db_invitation is None:
        raise HTTPException(status_code=404, detail="Invitation non trouvée")
    return db_invitation

@app.delete("/admin/invitations/{invitation_id}", response_model=schemas.Invitation, dependencies=[Depends(auth.require_admin)])
def delete_invitation(invitation_id: int, db: Session = Depends(get_db)):
    db_invitation = crud.delete_invitation(db=db, invitation_id=invitation_id)
    if db_invitation is None:
        raise HTTPException(status_code=404, detail="Invitation non trouvée")
    return db_invitation

@app.get("/admin/filterable-users", response_model=list[schemas.User], dependencies=[Depends(auth.require_admin)])
def read_filterable_users(db: Session = Depends(get_db)):
    return crud.get_all_users_for_filtering(db)

# --------------- END OF FILE: backend/main.py ---------------

# --------------- START OF FILE: backend/crud.py ---------------



# /crud.py

from sqlalchemy.orm import Session, joinedload, outerjoin
import models, schemas, auth
import secrets
from datetime import datetime, timedelta, timezone
from typing import Optional, List
from fastapi import HTTPException
from http import HTTPStatus

def get_user(db: Session, user_id: int):
    return db.query(models.User).filter(models.User.id == user_id).first()
def get_user_by_username(db: Session, username: str):
    return db.query(models.User).filter(models.User.user_name == username).first()
def get_user_by_email(db: Session, email: str):
    return db.query(models.User).filter(models.User.email == email).first()
def get_users(db: Session, skip: int = 0, limit: int = 100, name_filter: Optional[str] = None):
    # Exclude the admin user from the list of manageable users
    query = db.query(models.User).filter(models.User.user_name != "admin")
    if name_filter:
        search = f"%{name_filter}%"
        query = query.filter(
            models.User.first_name.ilike(search) |
            models.User.last_name.ilike(search) |
            models.User.user_name.ilike(search) |
            models.User.email.ilike(search)
        )
    return query.offset(skip).limit(limit).all()

def get_all_users_for_filtering(db: Session):
    # Return all users, including the admin, for filtering purposes
    return db.query(models.User).all()



def create_user(db: Session, user: schemas.UserCreate, token: Optional[str] = None, role: str = "user"):
    # If a token is provided, validate it (for public registration)
    if token:
        invitation = get_invitation_by_token(db, token)
        if not invitation or invitation.is_used or invitation.expires_at.replace(tzinfo=timezone.utc) < datetime.now(timezone.utc):
            return None # Invalid token
        db.delete(invitation)

    hashed_password = auth.get_password_hash(user.password)
    db_user = models.User(
        **user.model_dump(exclude={"password"}),
        hashed_password=hashed_password,
        role=role # Assign role
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def update_user(db: Session, user_id: int, user_update: schemas.UserUpdate):
    db_user = get_user(db, user_id)
    if not db_user: return None
    update_data = user_update.model_dump(exclude_unset=True)
    if "password" in update_data and update_data["password"]:
        hashed_password = auth.get_password_hash(update_data["password"])
        db_user.hashed_password = hashed_password
    update_data.pop("password", None)
    for key, value in update_data.items():
        setattr(db_user, key, value)
    db.commit()
    db.refresh(db_user)
    return db_user

def delete_user(db: Session, user_id: int):
    db_user = get_user(db, user_id)
    if db_user:
        db.delete(db_user)
        db.commit()
    return db_user

def get_passport(db: Session, passport_id: int):
    return db.query(models.Passport).filter(models.Passport.id == passport_id).first()

def get_passports(db: Session, skip: int = 0, limit: int = 100, user_filter: Optional[str] = None, voyage_filter: Optional[str] = None):
    query = db.query(models.Passport)
    if user_filter:
        if user_filter.isdigit():
            query = query.filter(models.Passport.owner_id == int(user_filter))
        else:
            query = query.join(models.User).filter(
                models.User.first_name.ilike(f"%{user_filter}%") |
                models.User.last_name.ilike(f"%{user_filter}%") |
                models.User.user_name.ilike(f"%{user_filter}%")
            )
    if voyage_filter:
        query = query.join(models.Passport.voyages)
        if voyage_filter.isdigit():
            query = query.filter(models.Voyage.id == int(voyage_filter))
        else:
            query = query.filter(models.Voyage.destination.ilike(f"%{voyage_filter}%"))
    return query.offset(skip).limit(limit).all()

def get_passports_by_user(db: Session, user_id: int):
    return db.query(models.Passport).filter(models.Passport.owner_id == user_id).all()

def create_user_passport(db: Session, passport: schemas.PassportCreate, user_id: int):
    # First, check if a passport with this number already exists for the current user.
    db_passport = db.query(models.Passport).filter(
        models.Passport.passport_number == passport.passport_number,
        models.Passport.owner_id == user_id
    ).first()

    # If the passport does not exist, create a new one.
    if not db_passport:
        passport_data = passport.model_dump(exclude={"destination", "confidence_score"})
        db_passport = models.Passport(
            **passport_data, 
            owner_id=user_id, 
            confidence_score=passport.confidence_score
        )
        db.add(db_passport)
        db.commit()
        db.refresh(db_passport)

    # Now, handle the destination/voyage association.
    if passport.destination:
        # Find the voyage for the user and destination.
        db_voyage = db.query(models.Voyage).filter(
            models.Voyage.user_id == user_id,
            models.Voyage.destination == passport.destination
        ).first()

        # If the voyage doesn't exist, create it.
        if not db_voyage:
            db_voyage = models.Voyage(destination=passport.destination, user_id=user_id)
            db.add(db_voyage)
            # We commit here to give the voyage an ID before associating it
            db.commit()
            db.refresh(db_voyage)

        # Check if the passport is already associated with this voyage.
        if db_passport not in db_voyage.passports:
            db_voyage.passports.append(db_passport)
            db.commit()
            db.refresh(db_passport)
    
    return db_passport

def update_passport(db: Session, passport_id: int, passport_update: schemas.PassportCreate):
    db_passport = get_passport(db, passport_id)
    if not db_passport:
        return None

    if passport_update.destination:
        existing_association = db.query(models.Passport).join(models.Passport.voyages).filter(
            models.Passport.owner_id == db_passport.owner_id,
            models.Passport.passport_number == passport_update.passport_number,
            models.Voyage.destination == passport_update.destination,
            models.Passport.id != passport_id
        ).first()
        if existing_association:
            raise HTTPException(
                status_code=HTTPStatus.CONFLICT,
                detail=f"Le passeport numéro '{passport_update.passport_number}' est déjà enregistré pour la destination '{passport_update.destination}'.",
            )

    update_data = passport_update.model_dump(exclude={"destination"})
    for key, value in update_data.items():
        setattr(db_passport, key, value)

    db_passport.voyages.clear()

    if passport_update.destination:
        db_voyage = db.query(models.Voyage).filter(
            models.Voyage.user_id == db_passport.owner_id,
            models.Voyage.destination == passport_update.destination
        ).first()
        if not db_voyage:
            db_voyage = models.Voyage(destination=passport_update.destination, user_id=db_passport.owner_id)
            db.add(db_voyage)
        db_passport.voyages.append(db_voyage)

    db.commit()
    db.refresh(db_passport)
    return db_passport

def delete_passport(db: Session, passport_id: int):
    db_passport = get_passport(db, passport_id)
    if db_passport:
        db.delete(db_passport)
        db.commit()
    return db_passport

def delete_passports_by_ids(db: Session, *, passport_ids: List[int], user_id: int, is_admin: bool):
    """
    Deletes multiple passports from the database based on a list of IDs.
    - If the user is not an admin, it will only delete passports that belong to them.
    """
    query = db.query(models.Passport).filter(models.Passport.id.in_(passport_ids))
    
    # Security check: Non-admins can only delete their own passports.
    if not is_admin:
        # Correctly checks against the 'owner_id' column
        query = query.filter(models.Passport.owner_id == user_id)
        
    num_deleted = query.delete(synchronize_session=False)
    db.commit()
    return num_deleted

def get_voyage(db: Session, voyage_id: int):
    return db.query(models.Voyage).filter(models.Voyage.id == voyage_id).first()

def get_voyages(db: Session, skip: int = 0, limit: int = 100, user_filter: Optional[str] = None):
    query = db.query(models.Voyage)
    if user_filter:
        if user_filter.isdigit():
            query = query.filter(models.Voyage.user_id == int(user_filter))
        else:
            query = query.join(models.User).filter(
                models.User.first_name.ilike(f"%{user_filter}%") |
                models.User.last_name.ilike(f"%{user_filter}%") |
                models.User.user_name.ilike(f"%{user_filter}%")
            )
    return query.offset(skip).limit(limit).all()

def get_voyages_by_user(db: Session, user_id: int):
    return db.query(models.Voyage).filter(models.Voyage.user_id == user_id).all()

def create_user_voyage(db: Session, voyage: schemas.VoyageCreate, user_id: int, passport_ids: list[int]):
    db_voyage = models.Voyage(destination=voyage.destination, user_id=user_id)
    if passport_ids:
        passports = db.query(models.Passport).filter(models.Passport.id.in_(passport_ids)).all()
        db_voyage.passports.extend(passports)
    db.add(db_voyage)
    db.commit()
    db.refresh(db_voyage)
    return db_voyage

def update_voyage(db: Session, voyage_id: int, voyage_update: schemas.VoyageCreate):
    db_voyage = get_voyage(db, voyage_id)
    if not db_voyage: return None
    db_voyage.destination = voyage_update.destination
    if voyage_update.passport_ids is not None:
        passports = db.query(models.Passport).filter(models.Passport.id.in_(voyage_update.passport_ids)).all()
        db_voyage.passports = passports
    db.commit()
    db.refresh(db_voyage)
    return db_voyage

def delete_voyage(db: Session, voyage_id: int):
    db_voyage = get_voyage(db, voyage_id)
    if db_voyage:
        db.delete(db_voyage)
        db.commit()
    return db_voyage

def filter_data(db: Session, destination: Optional[str], user_id: Optional[int], first_name: Optional[str], last_name: Optional[str]):
    query = db.query(models.Passport)

    if user_id is not None:
        query = query.filter(models.Passport.owner_id == user_id)

    if destination:
        query = query.join(models.Passport.voyages).filter(models.Voyage.destination.ilike(f"%{destination}%"))

    if first_name:
        query = query.filter(models.Passport.first_name.ilike(f"%{first_name}%"))
    if last_name:
        query = query.filter(models.Passport.last_name.ilike(f"%{last_name}%"))

    query = query.options(joinedload(models.Passport.voyages))
    
    results = query.all()
    
    data_list = []
    processed_passport_ids = set()

    for passport in results:
        if passport.id in processed_passport_ids:
            continue
        
        destinations = [v.destination for v in passport.voyages]
        if destination:
            dest_str = destination
        elif destinations:
            dest_str = ", ".join(sorted(list(set(destinations))))
        else:
            dest_str = "N/A"

        data_list.append({
            "id": passport.id, "first_name": passport.first_name, "last_name": passport.last_name,
            "birth_date": passport.birth_date, "delivery_date": passport.delivery_date,
            "expiration_date": passport.expiration_date, "nationality": passport.nationality,
            "passport_number": passport.passport_number, "owner_id": passport.owner_id,
            "destination": dest_str
        })
        processed_passport_ids.add(passport.id)
        
    return data_list

def create_invitation(db: Session, email: str):
    token = secrets.token_urlsafe(32)
    expires_at = datetime.now(timezone.utc) + timedelta(hours=24)
    db_invitation = models.Invitation(email=email, token=token, expires_at=expires_at)
    db.add(db_invitation)
    db.commit()
    db.refresh(db_invitation)
    return db_invitation




def get_invitation_by_token(db: Session, token: str):
    return db.query(models.Invitation).filter(models.Invitation.token == token).first()

def get_invitation_by_email(db: Session, email: str):
    return db.query(models.Invitation).filter(models.Invitation.email == email).first()

def get_invitation(db: Session, invitation_id: int):
    return db.query(models.Invitation).filter(models.Invitation.id == invitation_id).first()

def get_invitations(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.Invitation).offset(skip).limit(limit).all()

def update_invitation(db: Session, invitation_id: int, invitation_update: schemas.InvitationUpdate):
    db_invitation = get_invitation(db, invitation_id)
    if not db_invitation:
        return None
    update_data = invitation_update.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_invitation, key, value)
    db.commit()
    db.refresh(db_invitation)
    return db_invitation

def delete_invitation(db: Session, invitation_id: int):
    db_invitation = get_invitation(db, invitation_id)
    if db_invitation:
        db.delete(db_invitation)
        db.commit()
    return db_invitation

def get_destinations_by_user_id(db: Session, user_id: int) -> List[str]:
    query = db.query(models.Voyage.destination).filter(models.Voyage.user_id == user_id).distinct()
    destinations = [item[0] for item in query.all()]
    return destinations


# --------------- END OF FILE: backend/crud.py ---------------

# --------------- START OF FILE: backend/schemas.py ---------------

# backend/schemas.py

from pydantic import BaseModel, EmailStr
from typing import List, Optional, Any
from datetime import date, datetime

# --- NEW: Schemas for Asynchronous Task Handling ---

class AsyncTaskCreateResponse(BaseModel):
    """Response for a single task creation."""
    task_id: str
    filename: str

class MultiAsyncTaskResponse(BaseModel):
    """Response when multiple background tasks are created."""
    tasks: List[AsyncTaskCreateResponse]

class AsyncTaskStatus(BaseModel):
    """Response when checking the status of a background task."""
    task_id: str
    status: str # e.g., PENDING, PROGRESS, SUCCESS, FAILURE, CANCELLED
    progress: Optional[dict] = None # e.g., {"status": "Uploading..."}
    result: Optional[Any] = None # Will contain the final result on SUCCESS/FAILURE


# --- EXISTING SCHEMAS ---

class VoyageBase(BaseModel):
    destination: str

class VoyageCreate(VoyageBase):
    passport_ids: List[int] = []

class Voyage(VoyageBase):
    id: int
    user_id: int
    class Config:
        from_attributes = True

class PassportBase(BaseModel):
    first_name: str
    last_name: str
    birth_date: date
    expiration_date: Optional[date] = None
    delivery_date: Optional[date] = None
    nationality: str
    passport_number: str
    confidence_score: Optional[float] = None

class PassportCreate(PassportBase):
    destination: Optional[str] = None

class Passport(PassportBase):
    id: int
    owner_id: int
    voyages: List[Voyage] = []
    class Config:
        from_attributes = True

class UserBase(BaseModel):
    first_name: str
    last_name: str
    email: EmailStr
    phone_number: str
    user_name: str

class UserCreate(UserBase):
    password: str

class UserUpdate(BaseModel):
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    email: Optional[EmailStr] = None
    phone_number: Optional[str] = None
    password: Optional[str] = None

class User(UserBase):
    id: int
    role: str
    passports: List["Passport"] = []
    voyages: List[Voyage] = []
    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

class InvitationCreate(BaseModel):
    email: EmailStr

class Invitation(InvitationCreate):
    id: int
    token: str
    expires_at: datetime
    is_used: bool
    class Config:
        from_attributes = True

class InvitationUpdate(BaseModel):
    expires_at: Optional[datetime] = None
    is_used: Optional[bool] = None

class IdsList(BaseModel):
    ids: List[int]

User.model_rebuild()

# --------------- END OF FILE: backend/schemas.py ---------------

# --------------- START OF FILE: backend/models.py ---------------



# /models.py
from sqlalchemy import Boolean, Column, Integer, Float, String, Date, ForeignKey, Table, DateTime
from sqlalchemy.orm import relationship
from database import Base

voyage_passport_association = Table('voyage_passport_association', Base.metadata,
    Column('voyage_id', Integer, ForeignKey('voyages.id'), primary_key=True),
    Column('passport_id', Integer, ForeignKey('passports.id'), primary_key=True)
)

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    first_name = Column(String, index=True)
    last_name = Column(String, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    phone_number = Column(String)
    user_name = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    role = Column(String, default="user")
    passports = relationship("Passport", back_populates="owner", cascade="all, delete-orphan")
    voyages = relationship("Voyage", back_populates="user", cascade="all, delete-orphan")

class Passport(Base):
    __tablename__ = "passports"
    id = Column(Integer, primary_key=True, index=True)
    first_name = Column(String, index=True)
    last_name = Column(String, index=True)
    birth_date = Column(Date)
    delivery_date = Column(Date)
    expiration_date = Column(Date)
    nationality = Column(String, index=True)
    passport_number = Column(String, index=True, nullable=False) # Removed unique=True
    confidence_score = Column(Float)
    owner_id = Column(Integer, ForeignKey("users.id"))
    owner = relationship("User", back_populates="passports")
    voyages = relationship("Voyage", secondary=voyage_passport_association, back_populates="passports")


class Voyage(Base):
    __tablename__ = "voyages"
    id = Column(Integer, primary_key=True, index=True)
    destination = Column(String, index=True, nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"))
    user = relationship("User", back_populates="voyages")
    passports = relationship("Passport", secondary=voyage_passport_association, back_populates="voyages")

class Invitation(Base):
    __tablename__ = "invitations"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    token = Column(String, unique=True, index=True, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    is_used = Column(Boolean, default=False)


# --------------- END OF FILE: backend/models.py ---------------

# --------------- START OF FILE: backend/database.py ---------------

# /database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = "sqlite:///./data/travel_app.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# --------------- END OF FILE: backend/database.py ---------------

# --------------- START OF FILE: backend/auth.py ---------------


# /auth.py
from datetime import datetime, timedelta, timezone
from typing import Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlalchemy.orm import Session
import crud, models, schemas
from database import get_db
import os
from dotenv import load_dotenv # You'll need to install this library

# Load environment variables from a .env file (for local development)
load_dotenv()

SECRET_KEY = os.getenv("SECRET_KEY", "a_default_fallback_key_if_not_set")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto", bcrypt__ident="2b")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def authenticate_user(db: Session, username: str, password: str):
    user = crud.get_user_by_username(db, username=username)
    if not user or not verify_password(password, user.hashed_password):
        return False
    return user

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Impossible de valider les informations d'identification",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None: raise credentials_exception
        token_data = schemas.TokenData(username=username)
    except JWTError:
        raise credentials_exception
    user = crud.get_user_by_username(db, username=token_data.username)
    if user is None: raise credentials_exception
    return user

def get_current_active_user(current_user: models.User = Depends(get_current_user)):
    return current_user

def require_admin(current_user: models.User = Depends(get_current_active_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Privilèges d'administrateur requis.")
    return current_user


# --------------- END OF FILE: backend/auth.py ---------------

# --------------- START OF FILE: backend/prestart.sh ---------------

#!/bin/bash

# Run the database initialization script
python /app/initial_db.py

# Now, start the Gunicorn server
exec gunicorn -w 4 -k uvicorn.workers.UvicornWorker main:app --bind 0.0.0.0:8000

# --------------- END OF FILE: backend/prestart.sh ---------------

# --------------- START OF FILE: backend/initial_db.py ---------------

import logging
from database import engine, SessionLocal
import models
import crud
import schemas
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def init_db():
    logger.info("Creating initial database tables...")
    # The checkfirst=True is still a good safety measure
    models.Base.metadata.create_all(bind=engine, checkfirst=True)
    logger.info("Database tables created.")

    db = SessionLocal()
    # Check if admin user exists and create one if not
    admin_user = crud.get_user_by_username(db, username="admin")
    if not admin_user:
        logger.info("Admin user not found, creating one...")
        ADMIN_PASSWORD = os.getenv("ADMIN_PASSWORD")
        if not ADMIN_PASSWORD:
            logger.warning("ADMIN_PASSWORD environment variable not set. Admin user not created.")
        else:
            admin = schemas.UserCreate(
                first_name="Admin",
                last_name="User",
                email="admin@example.com",
                phone_number="1234567890",
                user_name="admin",
                password=ADMIN_PASSWORD
            )
            crud.create_user(db=db, user=admin, role="admin", token=None)
            logger.info("Admin user created.")
    else:
        logger.info("Admin user already exists.")
    db.close()

if __name__ == "__main__":
    init_db()

# --------------- END OF FILE: backend/initial_db.py ---------------

# --------------- START OF FILE: backend/ocr_service.py ---------------

# backend/ocr_service.py

import re
import os
import json
from datetime import datetime
from google.cloud import vision, storage
from fastapi import HTTPException
import logging
from typing import Tuple, Optional, Dict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --- Google Cloud Clients ---
# Initialize clients once and reuse them.
# Credentials will be picked up from the GOOGLE_APPLICATION_CREDENTIALS env var.
try:
    vision_client = vision.ImageAnnotatorClient()
    storage_client = storage.Client()
except Exception as e:
    logger.error(f"Could not initialize Google Cloud clients: {e}")
    # You might want to handle this more gracefully
    vision_client = None
    storage_client = None

GCS_BUCKET_NAME = os.getenv("GCS_BUCKET_NAME")

def _upload_to_gcs(file_path: str, destination_blob_name: str) -> str:
    """Uploads a file to the GCS bucket."""
    if not GCS_BUCKET_NAME or not storage_client:
        raise ValueError("GCS_BUCKET_NAME environment variable not set or storage client not initialized.")
    bucket = storage_client.bucket(GCS_BUCKET_NAME)
    blob = bucket.blob(destination_blob_name)
    blob.upload_from_filename(file_path)
    return f"gs://{GCS_BUCKET_NAME}/{destination_blob_name}"

def _delete_from_gcs(gcs_uri: str):
    """Deletes a file from the GCS bucket."""
    if not gcs_uri.startswith(f"gs://{GCS_BUCKET_NAME}/"):
        logger.error(f"Cannot delete blob: URI '{gcs_uri}' is not in the configured bucket.")
        return
    try:
        if not storage_client:
            logger.error("Storage client not initialized, cannot delete GCS blob.")
            return
        bucket = storage_client.bucket(GCS_BUCKET_NAME)
        blob_name = gcs_uri.replace(f"gs://{GCS_BUCKET_NAME}/", "")
        blob = bucket.blob(blob_name)
        blob.delete()
        logger.info(f"Successfully deleted blob: {gcs_uri}")
    except Exception as e:
        logger.error(f"Failed to delete blob {gcs_uri}: {e}")

def start_async_ocr_extraction(file_path: str, content_type: str) -> Tuple[str, str]:
    """
    Starts an asynchronous OCR job for a multi-page document.
    It uploads the file to GCS and triggers the batch annotation.
    """
    if not vision_client:
        raise RuntimeError("Google Vision client is not initialized.")
        
    if not content_type == "application/pdf":
        raise HTTPException(status_code=400, detail="Only multi-page PDF files are supported for batch processing.")

    # Create a unique name for the file in the GCS bucket
    timestamp = datetime.utcnow().strftime('%Y%m%d%H%M%S')
    unique_filename = f"uploads/{timestamp}-{os.path.basename(file_path)}"

    # 1. Upload the file to GCS
    try:
        gcs_source_uri = _upload_to_gcs(file_path, unique_filename)
        logger.info(f"File uploaded to GCS at: {gcs_source_uri}")
    except Exception as e:
        logger.error(f"Failed to upload to GCS: {e}")
        raise HTTPException(status_code=500, detail=f"Could not upload file to cloud storage: {e}")

    # 2. Configure and start the async OCR request
    gcs_destination_uri = f"gs://{GCS_BUCKET_NAME}/results/{unique_filename}-"
    mime_type = 'application/pdf'
    feature = vision.Feature(type_=vision.Feature.Type.DOCUMENT_TEXT_DETECTION)
    gcs_source = vision.GcsSource(uri=gcs_source_uri)
    input_config = vision.InputConfig(gcs_source=gcs_source, mime_type=mime_type)
    gcs_destination = vision.GcsDestination(uri=gcs_destination_uri)
    output_config = vision.OutputConfig(gcs_destination=gcs_destination, batch_size=5) # Group results for 5 pages into one JSON

    async_request = vision.AsyncAnnotateFileRequest(
        features=[feature],
        input_config=input_config,
        output_config=output_config
    )

    operation = vision_client.async_batch_annotate_files(requests=[async_request])
    logger.info(f"Started Google Vision async operation: {operation.operation.name}")

    # Return both the operation name (to track progress) and the original GCS URI (to delete later)
    return operation.operation.name, gcs_source_uri

def get_async_ocr_results(operation_name: str) -> dict:
    """
    Checks the status of a long-running OCR operation and returns the results if complete.
    """
    if not vision_client or not storage_client:
        raise RuntimeError("Google Cloud clients are not initialized.")
        
    logger.info(f"Checking operation status: {operation_name}")
    # This uses the default operations client from the vision_client
    operation_client = vision_client.transport.operations_client
    operation = operation_client.get_operation(name=operation_name)

    if not operation.done:
        return {"status": "PROCESSING"}

    if operation.error.message:
        logger.error(f"Operation failed: {operation.error.message}")
        return {"status": "FAILURE", "error": operation.error.message}

    # --- If done, process the results from GCS ---
    # The response is embedded in the operation metadata for file annotation
    from google.cloud.vision_v1.types import AsyncBatchAnnotateFilesResponse
    response = AsyncBatchAnnotateFilesResponse.from_json(operation.response.value)
    destination_uri = response.output_config.gcs_destination.uri
    
    prefix = destination_uri.replace(f"gs://{GCS_BUCKET_NAME}/", "")
    
    bucket = storage_client.bucket(GCS_BUCKET_NAME)
    blob_list = list(bucket.list_blobs(prefix=prefix)) # Get all result files

    results = []
    # Loop through all result files generated by Google Vision
    for blob in blob_list:
        json_string = blob.download_as_string()
        response_json = json.loads(json_string)
        
        for page_num_in_blob, page_response in enumerate(response_json['responses']):
            page_context = page_response.get('context', {})
            # Vision API gives page numbers starting from 1
            actual_page_num = page_context.get('page_number', page_num_in_blob + 1)
            try:
                if page_response.get('error'):
                    raise ValueError(page_response['error']['message'])
                
                full_text = page_response.get('fullTextAnnotation', {}).get('text', '')
                if not full_text:
                    raise ValueError("No text detected on page.")

                parsed_data = _parse_french_id_card_text(full_text)
                
                # Calculate an average confidence score for the page
                total_confidence = 0
                symbol_count = 0
                for page in page_response.get('fullTextAnnotation', {}).get('pages', []):
                    for block in page.get('blocks', []):
                        for paragraph in block.get('paragraphs', []):
                            for word in paragraph.get('words', []):
                                for symbol in word.get('symbols', []):
                                    total_confidence += symbol.get('confidence', 0)
                                    symbol_count += 1
                
                average_confidence = (total_confidence / symbol_count) if symbol_count > 0 else 0.0
                parsed_data['confidence_score'] = round(average_confidence, 4)

                results.append({"page_number": actual_page_num, "data": parsed_data, "status": "SUCCESS"})
            except Exception as e:
                logger.warning(f"Failed to parse page {actual_page_num}: {e}")
                results.append({"page_number": actual_page_num, "error": str(e), "status": "FAILURE"})
    
    # --- Clean up the result files from GCS after processing ---
    for blob in blob_list:
        blob.delete()
        
    return {"status": "SUCCESS", "results": results}


def cancel_google_ocr_operation(operation_name: str):
    """Requests cancellation of a Google Vision API operation."""
    try:
        if not vision_client:
            logger.error("Vision client not initialized, cannot cancel operation.")
            return
        logger.info(f"Requesting cancellation for operation: {operation_name}")
        vision_client.transport.operations_client.cancel_operation(name=operation_name)
    except Exception as e:
        logger.error(f"Failed to send cancellation request for operation {operation_name}: {e}")

def _parse_date(date_str: Optional[str]) -> Optional[str]:
    """Helper to parse and format date string."""
    if not date_str:
        return None
    try:
        # Assuming format DD.MM.YYYY or DD/MM/YYYY
        cleaned_date_str = date_str.replace('.', '/')
        dt_obj = datetime.strptime(cleaned_date_str, '%d/%m/%Y')
        return dt_obj.strftime('%Y-%m-%d')
    except ValueError:
        logger.warning(f"Could not parse date string: {date_str}")
        return None

def _parse_french_id_card_text(raw_text: str) -> Dict[str, Optional[str]]:
    """
    Parses raw OCR text from a French ID card to extract structured data.
    This parser is an educated guess and may need significant refinement
    based on the quality and format of your specific document scans.
    """
    data = {
        "first_name": None,
        "last_name": None,
        "passport_number": None,
        "birth_date": None,
        "delivery_date": None,
        "expiration_date": None,
        "nationality": "FRANCAISE", # Default for French ID
    }

    # Normalize text for easier regex matching
    text_lines = [line.strip() for line in raw_text.split('\n')]
    full_text_single_line = ' '.join(text_lines)

    # --- Regex for common fields ---
    # Passport Number (ID Card Number) - often 12 digits for CNIe
    id_match = re.search(r'(\b\d{2}[A-Z\d]{2}\s?\d{5}\b)', full_text_single_line)
    if id_match:
        data["passport_number"] = id_match.group(1).replace(" ", "")

    # Last Name (Nom)
    last_name_match = re.search(r'Nom\s*[:\s]+\s*([A-Z\s\'-]+)', raw_text, re.IGNORECASE)
    if last_name_match:
        data["last_name"] = last_name_match.group(1).strip()

    # First Name (Prénoms)
    first_name_match = re.search(r'Prénom\(s\)\s*[:\s]+\s*([A-Z\s\'-]+)', raw_text, re.IGNORECASE)
    if first_name_match:
        data["first_name"] = first_name_match.group(1).strip()

    # Birth Date (Né(e) le)
    birth_date_match = re.search(r'Né\(e\)\s+le\s+(\d{2}[./]\d{2}[./]\d{4})', raw_text, re.IGNORECASE)
    if birth_date_match:
        data["birth_date"] = _parse_date(birth_date_match.group(1))

    # --- Regex for dates based on proximity ---
    # Often dates appear in a sequence: DD.MM.YYYY - DD.MM.YYYY
    date_pattern = r'(\d{2}\.\d{2}\.\d{4})'
    all_dates = re.findall(date_pattern, full_text_single_line)
    if len(all_dates) >= 2:
        # A common pattern is Delivery Date then Expiry Date
        data["delivery_date"] = _parse_date(all_dates[0])
        data["expiration_date"] = _parse_date(all_dates[1])


    # --- Fallback using Machine Readable Zone (MRZ) if present ---
    # Example MRZ: IDFRA<LASTNAME><<FIRSTNAME<<<<<<<<<<<<<
    mrz_line = None
    for line in text_lines:
        if line.startswith('IDFRA'):
            mrz_line = line.replace(' ', '')
            break
    
    if mrz_line:
        if not data["passport_number"]:
             # Extract from first part of MRZ if available
             pass # MRZ format varies, add logic if needed.

        # MRZ parsing is complex, this is a simplified example
        parts = mrz_line[5:].split('<<')
        if len(parts) >= 2:
            if not data["last_name"]:
                data["last_name"] = parts[0].replace('<', ' ').strip()
            if not data["first_name"]:
                data["first_name"] = parts[1].replace('<', ' ').strip()

    # Final validation check
    if not all([data["last_name"], data["first_name"], data["birth_date"], data["passport_number"]]):
        missing_fields = [k for k, v in data.items() if v is None and k in ["last_name", "first_name", "birth_date", "passport_number"]]
        raise ValueError(f"Could not parse all required fields. Missing: {', '.join(missing_fields)}.")
        
    return data

# --------------- END OF FILE: backend/ocr_service.py ---------------

# --------------- START OF FILE: backend/celery_worker.py ---------------

# backend/celery_worker.py

import os
import time
from typing import Optional

import ocr_service
import crud
import schemas
from database import SessionLocal
from celery import Celery, Task
from celery.signals import task_revoked
from celery.utils.log import get_task_logger

# --- Celery Configuration ---
CELERY_BROKER_URL = os.getenv("CELERY_BROKER_URL", "redis://redis:6379/0")
CELERY_RESULT_BACKEND = os.getenv("CELERY_RESULT_BACKEND", "redis://redis:6379/0")

celery_app = Celery(
    "tasks",
    broker=CELERY_BROKER_URL,
    backend=CELERY_RESULT_BACKEND
)
celery_app.conf.update(
    accept_content=['json'],
    task_serializer='json',
    result_serializer='json',
    task_track_started=True, 
)

logger = get_task_logger(__name__)


# --- MODIFICATION START ---
@task_revoked.connect
def on_task_revoked(request, terminated, signum, expired, **kwargs):
    """
    Handler to log when a task is revoked.
    Cleanup is now handled entirely within the task's 'finally' block.
    """
    # The 'request' object here is a 'Request' class, not the task context.
    # We can get the task ID directly from it.
    logger.warning(
        f"Task {request.id} was revoked. "
        f"Terminated: {terminated}, Signal: {signum}, Expired: {expired}"
    )
# --- MODIFICATION END ---


@celery_app.task(bind=True, name='tasks.extract_document_data')
def extract_document_data(self, file_path: str, original_filename: str, content_type: str, destination: Optional[str], user_id: int):
    """
    Celery task to perform OCR, parse results, and save them to the database.
    """
    gcs_source_uri = None
    google_operation_name = None

    try:
        self.update_state(state='PROGRESS', meta={'status': 'Uploading to cloud...'})
        google_operation_name, gcs_source_uri = ocr_service.start_async_ocr_extraction(file_path, content_type)

        logger.info(f"Task {self.request.id} started Google operation {google_operation_name}")
        self.update_state(state='PROGRESS', meta={'status': 'Processing document...'})
        
        while True:
            if self.request.is_revoked():
                logger.warning(f"Task {self.request.id} is revoked during processing loop.")
                return {'status': 'CANCELLED', 'detail': 'Task was cancelled by user.'}

            result = ocr_service.get_async_ocr_results(google_operation_name)
            
            if result['status'] == 'SUCCESS':
                logger.info(f"Google operation {google_operation_name} succeeded.")
                
                self.update_state(state='PROGRESS', meta={'status': 'Saving results to database...'})
                
                db = SessionLocal()
                success_count = 0
                failures = []
                try:
                    for page_result in result.get('results', []):
                        if page_result.get('status') == 'SUCCESS':
                            passport_data = schemas.PassportCreate(
                                **page_result['data'],
                                destination=destination 
                            )
                            crud.create_user_passport(db=db, passport=passport_data, user_id=user_id)
                            success_count += 1
                        else:
                            failures.append({
                                "page": page_result.get('page_number', 'N/A'),
                                "error": page_result.get('error', 'Unknown parsing error')
                            })
                finally:
                    db.close()

                final_status = {
                    'status': 'COMPLETE',
                    'filename': original_filename,
                    'successful_pages': success_count,
                    'failed_pages': failures
                }
                return final_status

            elif result['status'] == 'FAILURE':
                logger.error(f"Google operation {google_operation_name} failed: {result.get('error')}")
                raise Exception(f"Google Vision API Error: {result.get('error', 'Unknown error')}")
            
            time.sleep(10)

    except Exception as e:
        logger.error(f"Error in Celery task {self.request.id}: {e}", exc_info=True)
        raise e
    finally:
        logger.info(f"Cleaning up resources for task {self.request.id}.")
        if self.request.is_revoked() and google_operation_name:
             ocr_service.cancel_google_ocr_operation(google_operation_name)
        if gcs_source_uri:
            ocr_service._delete_from_gcs(gcs_source_uri)
        if os.path.exists(file_path):
            os.remove(file_path)
            logger.info(f"Cleaned up temporary file: {file_path}")

# --------------- END OF FILE: backend/celery_worker.py ---------------

# --------------- START OF FILE: .github/workflows/deploy.yml ---------------

name: CI/CD Pipeline - Build, Push, and Deploy

on:
  push:
    branches: [ "main" ]

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Log in to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push backend image
      uses: docker/build-push-action@v4
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: ${{ secrets.DOCKERHUB_USERNAME }}/fastreact-backend:latest

    - name: Build and push frontend image
      uses: docker/build-push-action@v4
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: ${{ secrets.DOCKERHUB_USERNAME }}/fastreact-frontend:latest

  deploy-to-droplet:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
    - name: Deploy to DigitalOcean Droplet
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.DO_DROPLET_IP }}
        username: ${{ secrets.DO_SSH_USER }}
        key: ${{ secrets.DO_SSH_KEY }}
        script: |
          # Navigate to the project directory
          # IMPORTANT: Make sure 'fastreactapp' is your repo's folder name on the droplet
          cd fastreactapp
          
          # Update the repository code from GitHub
          git pull origin main
          
          # --- Create/Update Environment Files ---
          # 1. Create the .env.prod file from GitHub Secrets
          echo "SECRET_KEY=${{ secrets.SECRET_KEY }}" > .env.prod
          echo "ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}" >> .env.prod
          echo "GCS_BUCKET_NAME=${{ secrets.GCS_BUCKET_NAME }}" >> .env.prod
          echo "GOOGLE_APPLICATION_CREDENTIALS=/app/google-credentials.json" >> .env.prod
          echo "CELERY_BROKER_URL=redis://redis:6379/0" >> .env.prod
          echo "CELERY_RESULT_BACKEND=redis://redis:6379/0" >> .env.prod
          
          # 2. The step that overwrites google-credentials.json has been REMOVED.
          # Your manually placed credentials file on the droplet will now be preserved.
          
          # --- Deploy with Docker Compose ---
          # Login to Docker Hub on the server
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          
          # Pull the latest images from Docker Hub
          # NOTE: Ensure your compose file on the server is named 'docker-compose.yml' or change this command.
          docker-compose -f docker-compose.yml pull
          
          # Restart the services with the new images in detached mode
          docker-compose -f docker-compose.yml up -d
          
          # Clean up old, unused Docker images to save space
          docker image prune -f

# --------------- END OF FILE: .github/workflows/deploy.yml ---------------

# --------------- START OF FILE: backend/Dockerfile ---------------

# Use an official Python runtime as a parent image
FROM python:3.11-slim

# Set the working directory in the container
WORKDIR /app

# Copy the requirements file into the container at /app
COPY ./requirements.txt /app/requirements.txt

# Install any needed packages specified in requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of the backend application's code into the container at /app
COPY . /app

# Make the prestart script executable
RUN chmod +x /app/prestart.sh

# Run the prestart script which will then start Gunicorn
CMD ["/app/prestart.sh"]

# --------------- END OF FILE: backend/Dockerfile ---------------

# --------------- START OF FILE: frontend/src/App.jsx ---------------

// frontend/src/App.jsx

import React, { useState, useEffect, useCallback, useRef } from 'react';

const API_URL = '/api';

// --- STYLES COMPONENT (Integrated, with NEW styles for progress bars) ---
const GlobalStyles = () => (
    <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        :root {
            --primary-color: #2a6fdb; --primary-hover: #1e5a9b; --secondary-color: #6c757d;
            --background-color: #f8f9fa; --surface-color: #ffffff; --text-color: #212529;
            --border-color: #dee2e6; --danger-color: #dc3545; --danger-hover: #a71d2a;
            --success-color: #198754; --warning-color: #ffc107; --font-family: 'Inter', sans-serif;
        }
        body { font-family: var(--font-family); background-color: var(--background-color); color: var(--text-color); margin: 0; line-height: 1.6; }
        .container { max-width: 1200px; margin: 0 auto; padding: 2rem; }
        .app-header { display: flex; justify-content: space-between; align-items: center; background-color: var(--surface-color); padding: 1.5rem 2rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05); margin-bottom: 2rem; }
        .app-header h1 { font-size: 2rem; font-weight: 700; color: var(--primary-color); margin: 0; }
        .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease-in-out; text-align: center; }
        .btn:disabled { background-color: var(--secondary-color); cursor: not-allowed; opacity: 0.7; }
        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-hover); transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .btn-danger { background-color: var(--danger-color); color: white; }
        .btn-danger:hover:not(:disabled) { background-color: var(--danger-hover); }
        .form-container { background-color: var(--surface-color); padding: 2.5rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); max-width: 500px; margin: 2rem auto; }
        .form-container h2 { text-align: center; margin-bottom: 2rem; font-size: 1.75rem; }
        .form-group { margin-bottom: 1.5rem; }
        .form-group label { display: block; margin-bottom: 0.5rem; font-weight: 500; color: var(--secondary-color); }
        .form-input { width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; font-size: 1rem; box-sizing: border-box; }
        .form-input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(42, 111, 219, 0.2); }
        .form-checkbox { width: 1.25rem; height: 1.25rem; cursor: pointer; }
        .password-container { position: relative; display: flex; align-items: center; }
        .password-container .form-input { padding-right: 40px; }
        .password-toggle-btn { position: absolute; right: 10px; background: none; border: none; cursor: pointer; color: var(--secondary-color); padding: 0; display: flex; align-items: center; justify-content: center; }
        .error-message { background-color: rgba(220, 53, 69, 0.1); color: var(--danger-color); padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; text-align: center; }
        .success-message { background-color: rgba(25, 135, 84, 0.1); color: var(--success-color); padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; text-align: center; }
        .info-message { background-color: #eef2f7; color: #334d6e; padding: 1rem; border-radius: 8px; }
        .dashboard-layout { display: grid; grid-template-columns: 250px 1fr; gap: 2rem; }
        .dashboard-nav { background-color: var(--surface-color); padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); align-self: start; }
        .dashboard-nav h3 { margin-top: 0; font-size: 1.25rem; }
        .nav-menu { display: flex; flex-direction: column; gap: 0.5rem; }
        .nav-button { text-align: left; padding: 0.75rem 1rem; border: none; background-color: transparent; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: 500; width: 100%; transition: background-color 0.2s, color 0.2s; }
        .nav-button:hover { background-color: #f1f3f5; }
        .nav-button.active { background-color: var(--primary-color); color: white; }
        .dashboard-content { background-color: var(--surface-color); padding: 2rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); }
        .dashboard-content h2 { margin-top: 0; margin-bottom: 2rem; font-size: 1.75rem; }
        .table-container { overflow-x: auto; border: 1px solid var(--border-color); border-radius: 12px; }
        .table { width: 100%; border-collapse: collapse; }
        .table th, .table td { padding: 1rem; text-align: left; border-bottom: 1px solid var(--border-color); white-space: normal; }
        .table thead th { background-color: #f8f9fa; font-weight: 600; }
        .table tbody tr:last-child td { border-bottom: none; }
        .table tbody tr:hover { background-color: #f1f3f5; }
        .filter-bar { display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; }
        .capitalize { text-transform: capitalize; }
        .text-center { text-align: center; }
        .mt-1 { margin-top: 1rem; }
        .mt-2 { margin-top: 2rem; }
        .mb-1 { margin-bottom: 1rem; }
        .mb-2 { margin-bottom: 2rem; }
        .results-container { margin-top: 2rem; }
        .results-summary { font-size: 1.1rem; font-weight: 600; margin-bottom: 1rem; }
        .results-list { list-style-type: none; padding: 0; max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; }
        .results-list li { display: flex; align-items: center; padding: 0.75rem 1rem; border-bottom: 1px solid var(--border-color); }
        .results-list li:last-child { border-bottom: none; }
        .result-icon { margin-right: 1rem; }
        .result-success .result-icon { color: var(--success-color); }
        .result-failure .result-icon { color: var(--danger-color); }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--surface-color); padding: 2.5rem; border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.15); width: 90%; max-width: 450px; }
        .modal-header { margin-bottom: 1.5rem; }
        .modal-header h3 { margin: 0; font-size: 1.5rem; }
        .modal-body { margin-bottom: 2rem; font-size: 1rem; color: var(--secondary-color); }
        .modal-footer { display: flex; justify-content: flex-end; gap: 1rem; }
        .notification { position: fixed; top: 20px; right: 20px; padding: 1rem 1.5rem; border-radius: 8px; color: white; z-index: 1001; box-shadow: 0 4px 12px rgba(0,0,0,0.1); animation: fadeInOut 4s ease-in-out; }
        .notification.error { background-color: var(--danger-color); }
        @keyframes fadeInOut { 0% { opacity: 0; transform: translateY(-10px); } 10% { opacity: 1; transform: translateY(0); } 90% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-10px); } }

        /* --- NEW STYLES FOR UPLOADER --- */
        .upload-list { list-style: none; padding: 0; margin-top: 1.5rem; }
        .upload-item { display: flex; align-items: center; gap: 1rem; padding: 1rem; border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 1rem; }
        .upload-item-info { flex-grow: 1; }
        .upload-item-info p { margin: 0; font-weight: 500; }
        .upload-item-info small { color: var(--secondary-color); text-transform: capitalize; }
        .progress-bar-container { width: 100%; background-color: #e9ecef; border-radius: 8px; overflow: hidden; height: 10px; margin-top: 0.5rem; }
        .progress-bar { height: 100%; width: 0%; background-color: var(--primary-color); transition: width 0.3s ease-in-out; }
        .progress-bar.processing { animation: pulse 2s infinite; }
        .progress-bar.success { background-color: var(--success-color); }
        .progress-bar.failure { background-color: var(--danger-color); }
        .progress-bar.cancelled { background-color: var(--secondary-color); }
        @keyframes pulse { 0% { background-color: #a8c5f0; } 50% { background-color: var(--primary-color); } 100% { background-color: #a8c5f0; } }

    `}</style>
);

const columnTranslations = {
    first_name: 'Prénom', last_name: 'Nom de famille', birth_date: 'Date de Naissance',
    delivery_date: 'Date de Délivrance', expiration_date: "Date d'Expiration", nationality: 'Nationalité',
    passport_number: 'Numéro de Passeport', confidence_score: 'Score de Confiance', email: 'Email',
    phone_number: 'Numéro de Téléphone', user_name: "Nom d'Utilisateur", role: 'Rôle',
    destination: 'Destination', token: 'Jeton', expires_at: 'Expire Le', is_used: 'Utilisé', actions: 'Actions'
};

const EyeIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>);
const EyeOffIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>);
function PasswordInput({ value, onChange, name, placeholder, required = false }) {
    const [showPassword, setShowPassword] = useState(false);
    return (
        <div className="password-container">
            <input type={showPassword ? 'text' : 'password'} name={name} value={value} onChange={onChange} className="form-input" placeholder={placeholder} required={required} autoComplete="new-password" />
            <button type="button" className="password-toggle-btn" onClick={() => setShowPassword(!showPassword)} aria-label={showPassword ? 'Cacher le mot de passe' : 'Afficher le mot de passe'}>
                {showPassword ? <EyeOffIcon /> : <EyeIcon />}
            </button>
        </div>
    );
}

function Modal({ isOpen, onClose, onConfirm, title, children }) {
    if (!isOpen) return null;
    return (
        <div className="modal-overlay" onClick={onClose}>
            <div className="modal-content" onClick={e => e.stopPropagation()}>
                <div className="modal-header"><h3>{title}</h3></div>
                <div className="modal-body">{children}</div>
                <div className="modal-footer">
                    <button onClick={onClose} className="btn" style={{ backgroundColor: 'var(--secondary-color)', color: 'white' }}>Annuler</button>
                    <button onClick={onConfirm} className="btn btn-danger">Confirmer</button>
                </div>
            </div>
        </div>
    );
}

function Notification({ message, type, onClear }) {
    useEffect(() => {
        const timer = setTimeout(() => { onClear(); }, 4000);
        return () => clearTimeout(timer);
    }, [onClear]);

    if (!message) return null;
    return <div className={`notification ${type}`}>{message}</div>;
}

export default function App() {
    const [token, setToken] = useState(localStorage.getItem('token'));
    const [user, setUser] = useState(null);
    const [view, setView] = useState('login');
    const logout = useCallback(() => { localStorage.removeItem('token'); setToken(null); setUser(null); window.history.pushState({}, '', '/'); setView('login'); }, []);
    const fetchUser = useCallback(async () => {
        const currentToken = localStorage.getItem('token');
        if (currentToken) {
            try {
                const response = await fetch(`${API_URL}/users/me`, { headers: { 'Authorization': `Bearer ${currentToken}` } });
                if (response.ok) { const data = await response.json(); setUser(data); setView('dashboard'); } else { logout(); }
            } catch (error) { console.error("Échec de la récupération de l'utilisateur:", error); logout(); }
        } else {
            const path = window.location.pathname;
            if (path.startsWith('/register/')) { setView('register'); } else { setView('login'); }
        }
    }, [logout]);
    useEffect(() => {
        fetchUser();
        const handlePopState = () => fetchUser();
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
    }, [fetchUser]);
    const renderView = () => {
        const path = window.location.pathname;
        if (view === 'register' || path.startsWith('/register/')) { const registrationToken = path.split('/')[2]; return <RegistrationPage registrationToken={registrationToken} />; }
        switch (view) {
            case 'login': return <Login setToken={setToken} fetchUser={fetchUser} />;
            case 'dashboard': return <Dashboard user={user} logout={logout} token={token} fetchUser={fetchUser} />;
            default: return <Login setToken={setToken} fetchUser={fetchUser} />;
        }
    };
    return (<><GlobalStyles /><div className="container"><header className="app-header"><h1>Gestionnaire de Voyages</h1>{user && <button onClick={logout} className="btn btn-danger">Déconnexion</button>}</header><main>{renderView()}</main></div></>);
}

function Login({ setToken, fetchUser }) {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [isLoading, setIsLoading] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setIsLoading(true);
        const formData = new URLSearchParams({ username, password });
        try {
            const response = await fetch(`${API_URL}/token`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: formData, });
            if (response.ok) {
                const data = await response.json();
                localStorage.setItem('token', data.access_token);
                setToken(data.access_token);
                fetchUser();
            } else {
                if (response.status === 429) {
                    setError("Trop de tentatives de connexion. Veuillez réessayer dans une minute.");
                } else {
                    const errorData = await response.json();
                    setError(errorData.detail || 'Échec de la connexion.');
                }
            }
        } catch (err) {
            setError('Une erreur est survenue. Veuillez réessayer.');
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="form-container">
            <h2>Connexion</h2>
            {error && <p className="error-message">{error}</p>}
            <form onSubmit={handleSubmit}>
                <div className="form-group">
                    <label>Nom d'utilisateur</label>
                    <input type="text" value={username} onChange={e => setUsername(e.target.value)} className="form-input" required />
                </div>
                <div className="form-group">
                    <label>Mot de passe</label>
                    <PasswordInput name="password" value={password} onChange={e => setPassword(e.target.value)} required={true} />
                </div>
                <button type="submit" className="btn btn-primary" style={{ width: '100%' }} disabled={isLoading}>
                    {isLoading ? 'Connexion en cours...' : 'Se connecter'}
                </button>
            </form>
        </div>
    );
}

function RegistrationPage({ registrationToken }) {
    const [formData, setFormData] = useState({ first_name: '', last_name: '', email: '', phone_number: '', user_name: '', password: '' });
    const [error, setError] = useState('');
    const [success, setSuccess] = useState('');
    const [isLoading, setIsLoading] = useState(true);
    useEffect(() => {
        const fetchInvitation = async () => {
            if (!registrationToken) { setError("Aucun jeton d'inscription fourni."); setIsLoading(false); return; }
            try {
                const response = await fetch(`${API_URL}/invitations/${registrationToken}`);
                if (response.ok) { const data = await response.json(); setFormData(prev => ({ ...prev, email: data.email })); } else { setError((await response.json()).detail || "Lien d'inscription invalide ou expiré."); }
            } catch (err) { setError("Une erreur est survenue lors de la validation du lien d'inscription."); } finally { setIsLoading(false); }
        };
        fetchInvitation();
    }, [registrationToken]);
    const handleChange = (e) => setFormData({ ...formData, [e.target.name]: e.target.value });
    const handleSubmit = async (e) => {
        e.preventDefault(); setError(''); setSuccess('');
        try {
            const response = await fetch(`${API_URL}/users/?token=${registrationToken}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(formData) });
            if (response.ok) { setSuccess('Inscription réussie ! Vous allez être redirigé vers la page de connexion.'); setTimeout(() => { window.history.pushState({}, '', '/'); window.location.reload(); }, 2000); } else { setError((await response.json()).detail || "Échec de l'inscription."); }
        } catch (err) { setError("Une erreur est survenue lors de l'inscription."); }
    };
    if (isLoading) return <p className="info-message">Chargement...</p>;
    if (success) return <div className="form-container"><p className="success-message">{success}</p></div>
    return (<div className="form-container"><h2>Créer un nouveau compte</h2>{error && <p className="error-message">{error}</p>}<form onSubmit={handleSubmit}><div className="form-group"><label>Prénom</label><input type="text" name="first_name" value={formData.first_name} onChange={handleChange} className="form-input" required /></div><div className="form-group"><label>Nom de famille</label><input type="text" name="last_name" value={formData.last_name} onChange={handleChange} className="form-input" required /></div><div className="form-group"><label>Email</label><input type="email" name="email" value={formData.email} onChange={handleChange} className="form-input" required readOnly /></div><div className="form-group"><label>Numéro de téléphone</label><input type="text" name="phone_number" value={formData.phone_number} onChange={handleChange} className="form-input" required /></div><div className="form-group"><label>Nom d'utilisateur</label><input type="text" name="user_name" value={formData.user_name} onChange={handleChange} className="form-input" required /></div><div className="form-group"><label>Mot de passe</label><PasswordInput name="password" value={formData.password} onChange={handleChange} required={true} /></div><button type="submit" className="btn btn-primary" style={{ width: '100%' }}>S'inscrire</button></form></div>);
}

function Dashboard({ user, token, fetchUser }) {
    const [activeTab, setActiveTab] = useState('passports');
    const [filterableUsers, setFilterableUsers] = useState([]);
    const [userSpecificDestinations, setUserSpecificDestinations] = useState([]);

    const fetchAdminData = useCallback(async () => {
        if (user.role !== 'admin') return;
        try {
            const filterableUsersRes = await fetch(`${API_URL}/admin/filterable-users`, { headers: { 'Authorization': `Bearer ${token}` } });
            if (filterableUsersRes.ok) setFilterableUsers(await filterableUsersRes.json());
        } catch (error) { console.error("Échec de la récupération des données admin:", error); }
    }, [user, token]);

    const fetchUserDestinations = useCallback(async () => {
        try {
            const response = await fetch(`${API_URL}/destinations/`, { headers: { 'Authorization': `Bearer ${token}` } });
            if (response.ok) setUserSpecificDestinations(await response.json());
        } catch (error) { console.error("Échec de la récupération des destinations de l'utilisateur:", error); }
    }, [token]);

    useEffect(() => { fetchAdminData(); fetchUserDestinations(); }, [fetchAdminData, fetchUserDestinations]);

    const renderTabContent = () => {
        const passportFilterConfig = user.role === 'admin'
            ? [{ name: 'user_filter', placeholder: 'Filtrer par Utilisateur', options: filterableUsers, getOptionValue: (o) => o.id, getOptionLabel: (o) => `${o.first_name} ${o.last_name} (${o.user_name})` }]
            : null;
        const voyageFilterConfig = user.role === 'admin'
            ? [{ name: 'user_filter', placeholder: 'Filtrer par Utilisateur', options: filterableUsers, getOptionValue: (o) => o.id, getOptionLabel: (o) => `${o.first_name} ${o.last_name} (${o.user_name})` }]
            : null;
        const passportFields = { first_name: 'text', last_name: 'text', birth_date: 'date', delivery_date: 'date', expiration_date: 'date', nationality: 'text', passport_number: 'text', destination: 'text', confidence_score: 'number' };

        switch (activeTab) {
            case 'account': return <AccountEditor user={user} token={token} fetchUser={fetchUser} />;
            case 'passports': return <CrudManager title="Gérer les Passeports" endpoint="passports" token={token} user={user} fields={passportFields} filterConfig={passportFilterConfig} />;
            case 'voyages': return <CrudManager title="Gérer les Voyages" endpoint="voyages" token={token} user={user} fields={{ destination: 'text' }} filterConfig={voyageFilterConfig} />;
            case 'tools_export': return <ToolsAndExportPanel token={token} user={user} adminUsers={filterableUsers} userDestinations={userSpecificDestinations} />;
            case 'users': return user.role === 'admin' ? <CrudManager title="Gérer les Utilisateurs" endpoint="admin/users" token={token} user={user} fields={{ first_name: 'text', last_name: 'text', email: 'email', phone_number: 'text', user_name: 'text', password: 'password', role: 'text' }} /> : null;
            case 'invitations': return user.role === 'admin' ? <CrudManager title="Gérer les Invitations" endpoint="admin/invitations" token={token} user={user} fields={{ email: 'email', token: 'text', expires_at: 'datetime-local', is_used: 'checkbox' }} /> : null;
            default: return null;
        }
    };
    return (
        <div className="dashboard-layout">
            <nav className="dashboard-nav">
                <h3>Bienvenue, {user.first_name}!</h3>
                <div className="nav-menu">
                    <button onClick={() => setActiveTab('account')} className={`nav-button ${activeTab === 'account' ? 'active' : ''}`}>Mon Compte</button>
                    <button onClick={() => setActiveTab('passports')} className={`nav-button ${activeTab === 'passports' ? 'active' : ''}`}>Passeports</button>
                    <button onClick={() => setActiveTab('voyages')} className={`nav-button ${activeTab === 'voyages' ? 'active' : ''}`}>Voyages</button>
                    <button onClick={() => setActiveTab('tools_export')} className={`nav-button ${activeTab === 'tools_export' ? 'active' : ''}`}>Outils & Exportation</button>
                    {user.role === 'admin' && (
                        <> <hr />
                            <button onClick={() => setActiveTab('users')} className={`nav-button ${activeTab === 'users' ? 'active' : ''}`}>Gérer les Utilisateurs</button>
                            <button onClick={() => setActiveTab('invitations')} className={`nav-button ${activeTab === 'invitations' ? 'active' : ''}`}>Gérer les Invitations</button>
                        </>
                    )}
                </div>
            </nav>
            <div className="dashboard-content">{renderTabContent()}</div>
        </div>
    );
}

function AccountEditor({ user, token, fetchUser }) {
    const [formData, setFormData] = useState({ first_name: '', last_name: '', email: '', phone_number: '', password: '' });
    const [message, setMessage] = useState('');
    useEffect(() => { if (user) setFormData({ first_name: user.first_name, last_name: user.last_name, email: user.email, phone_number: user.phone_number, password: '' }); }, [user]);
    const handleChange = (e) => setFormData({ ...formData, [e.target.name]: e.target.value });
    const handleSubmit = async (e) => {
        e.preventDefault(); setMessage(''); const payload = { ...formData }; if (!payload.password) delete payload.password;
        const response = await fetch(`${API_URL}/users/me`, { method: 'PUT', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` }, body: JSON.stringify(payload) });
        if (response.ok) { setMessage('Compte mis à jour avec succès !'); fetchUser(); } else { setMessage('Échec de la mise à jour du compte.'); }
    };
    return (<div><h2>Modifier Mon Compte</h2>{message && <p className="success-message">{message}</p>}<form onSubmit={handleSubmit}><div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}><div className="form-group"><label>Prénom</label><input type="text" name="first_name" value={formData.first_name} onChange={handleChange} className="form-input" /></div><div className="form-group"><label>Nom de famille</label><input type="text" name="last_name" value={formData.last_name} onChange={handleChange} className="form-input" /></div><div className="form-group"><label>Email</label><input type="email" name="email" value={formData.email} onChange={handleChange} className="form-input" /></div><div className="form-group"><label>Numéro de téléphone</label><input type="text" name="phone_number" value={formData.phone_number} onChange={handleChange} className="form-input" /></div></div><div className="form-group"><label>Nouveau mot de passe (optionnel)</label><PasswordInput name="password" value={formData.password} onChange={handleChange} placeholder="Laisser vide pour conserver le mot de passe actuel" /></div><button type="submit" className="btn btn-primary">Enregistrer les modifications</button></form></div>);
}

function OcrUploader({ token, onUploadSuccess }) {
    const [uploadTasks, setUploadTasks] = useState([]);
    const [destination, setDestination] = useState('');
    const [destinations, setDestinations] = useState([]);
    const pollingIntervals = useRef({});

    useEffect(() => {
        const fetchDestinations = async () => {
            try {
                const response = await fetch(`${API_URL}/destinations/`, { headers: { 'Authorization': `Bearer ${token}` } });
                if (response.ok) setDestinations(await response.json());
            } catch (error) { console.error("Failed to fetch destinations:", error); }
        };
        fetchDestinations();
    }, [token]);

    useEffect(() => {
        return () => {
            Object.values(pollingIntervals.current).forEach(clearInterval);
        };
    }, []);

    const handleFileChange = (e) => {
        const newFiles = Array.from(e.target.files).map(file => ({
            id: `${file.name}-${file.lastModified}`,
            file: file,
            status: 'WAITING', // 'WAITING', 'PENDING', 'PROGRESS', 'SUCCESS', 'FAILURE', 'CANCELLED'
            progress: { status: 'En attente de traitement...' },
            taskId: null,
            result: null
        }));
        setUploadTasks(prev => [...prev, ...newFiles]);
        e.target.value = null; // Reset file input
    };

    const pollTaskStatus = useCallback((taskId, fileId) => {
        pollingIntervals.current[taskId] = setInterval(async () => {
            try {
                const response = await fetch(`${API_URL}/tasks/${taskId}/status`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) throw new Error('Network response was not ok.');
                
                const data = await response.json();

                setUploadTasks(prev => prev.map(task =>
                    task.id === fileId ? { ...task, status: data.status, progress: data.progress || task.progress, result: data.result } : task
                ));

                if (['SUCCESS', 'FAILURE', 'CANCELLED'].includes(data.status)) {
                    clearInterval(pollingIntervals.current[taskId]);
                    delete pollingIntervals.current[taskId];
                    onUploadSuccess(true); // Signal to refresh data in the main view
                }
            } catch (error) {
                console.error("Polling error:", error);
                clearInterval(pollingIntervals.current[taskId]);
                delete pollingIntervals.current[taskId];
                setUploadTasks(prev => prev.map(task =>
                    task.id === fileId ? { ...task, status: 'FAILURE', progress: { status: 'Erreur de suivi.' } } : task
                ));
            }
        }, 5000); // Poll every 5 seconds
    }, [token, onUploadSuccess]);

    const handleSubmit = async () => {
        const filesToUpload = uploadTasks.filter(task => task.status === 'WAITING');
        if (filesToUpload.length === 0) return;

        const formData = new FormData();
        filesToUpload.forEach(task => {
            formData.append('files', task.file);
        });
        if (destination) formData.append('destination', destination);
        
        // Mark files as pending immediately for better UX
        setUploadTasks(prev => prev.map(t => filesToUpload.find(f => f.id === t.id) ? { ...t, status: 'PENDING' } : t));

        try {
            const response = await fetch(`${API_URL}/passports/upload-and-extract/`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}` },
                body: formData
            });

            if (response.status === 202) {
                const data = await response.json(); // Expects { tasks: [{ task_id, filename }] }
                data.tasks.forEach(createdTask => {
                    const matchingFile = filesToUpload.find(f => f.file.name === createdTask.filename);
                    if (matchingFile) {
                        setUploadTasks(prev => prev.map(t =>
                            t.id === matchingFile.id ? { ...t, taskId: createdTask.task_id, status: 'PROGRESS', progress: { status: 'En cours de traitement...' } } : t
                        ));
                        pollTaskStatus(createdTask.task_id, matchingFile.id);
                    }
                });
            } else {
                const errorData = await response.json();
                setUploadTasks(prev => prev.map(t =>
                    filesToUpload.find(f => f.id === t.id) ? { ...t, status: 'FAILURE', progress: { status: errorData.detail || 'Upload failed.' } } : t
                ));
            }
        } catch (err) {
            console.error("Upload error:", err);
            setUploadTasks(prev => prev.map(t =>
                filesToUpload.find(f => f.id === t.id) ? { ...t, status: 'FAILURE', progress: { status: 'Erreur réseau.' } } : t
            ));
        }
    };
    
    const handleCancel = async (taskToCancel) => {
        if (!taskToCancel.taskId) return; // Can't cancel if no task ID yet
        
        clearInterval(pollingIntervals.current[taskToCancel.taskId]);
        delete pollingIntervals.current[taskToCancel.taskId];
        
        try {
            await fetch(`${API_URL}/tasks/${taskToCancel.taskId}/cancel`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}` }
            });
            setUploadTasks(prev => prev.map(task =>
                task.id === taskToCancel.id ? { ...task, status: 'CANCELLED', progress: { status: 'Annulation demandée.'} } : task
            ));
        } catch (error) {
            console.error("Failed to send cancel request:", error);
        }
    };
    
    const handleRemoveTask = (idToRemove) => {
        setUploadTasks(prev => prev.filter(task => task.id !== idToRemove));
    };

    const handleFinishAndClear = () => {
        setUploadTasks([]);
        onUploadSuccess(false); // Close the uploader view
    };

    const isUploading = uploadTasks.some(t => ['PENDING', 'PROGRESS'].includes(t.status));
    const waitingCount = uploadTasks.filter(t => t.status === 'WAITING').length;
    
    const getProgressBarClass = (status) => {
        switch(status) {
            case 'SUCCESS': return 'success';
            case 'FAILURE': return 'failure';
            case 'CANCELLED': return 'cancelled';
            case 'PROGRESS':
            case 'PENDING': return 'processing';
            default: return '';
        }
    }

    return (
        <div className="form-container" style={{ maxWidth: 'none', margin: 0, padding: '2rem' }}>
            <h3>Ajouter des Passeports via Téléchargement</h3>
            <div className="form-group">
                <label>Destination (Optionnel)</label>
                <input type="text" value={destination} onChange={(e) => setDestination(e.target.value)} className="form-input" list="destination-datalist-ocr" placeholder="Appliquer à tous les passeports des fichiers" autoComplete="off" />
                <datalist id="destination-datalist-ocr">{destinations.map(dest => <option key={dest} value={dest} />)}</datalist>
            </div>
            <div className="form-group">
                <label>Documents PDF (plusieurs fichiers possibles)</label>
                <input type="file" onChange={handleFileChange} accept="application/pdf" className="form-input" multiple disabled={isUploading} />
            </div>

            <ul className="upload-list">
                {uploadTasks.map(task => (
                    <li key={task.id} className="upload-item">
                        <div className="upload-item-info">
                            <p>{task.file.name}</p>
                            <small>{task.progress?.status || task.status}</small>
                            <div className="progress-bar-container">
                                <div
                                    className={`progress-bar ${getProgressBarClass(task.status)}`}
                                    style={{ width: ['SUCCESS', 'FAILURE', 'CANCELLED'].includes(task.status) ? '100%' : (['PROGRESS', 'PENDING'].includes(task.status) ? '50%' : '0%') }}
                                ></div>
                            </div>
                            {task.status === 'SUCCESS' && task.result && (
                                <small style={{color: 'var(--success-color)'}}>
                                    Succès: {task.result.successful_pages}, Échecs: {task.result.failed_pages?.length || 0}
                                </small>
                            )}
                             {task.status === 'FAILURE' && (
                                <small style={{color: 'var(--danger-color)'}}>
                                    Échec: {task.result || 'Une erreur est survenue.'}
                                </small>
                            )}
                        </div>
                        {['PENDING', 'PROGRESS'].includes(task.status) && (
                            <button onClick={() => handleCancel(task)} className="btn btn-danger">Annuler</button>
                        )}
                        {['SUCCESS', 'FAILURE', 'CANCELLED', 'WAITING'].includes(task.status) && (
                            <button onClick={() => handleRemoveTask(task.id)} className="btn" style={{backgroundColor: 'transparent', color: 'var(--danger-color)'}}>✕</button>
                        )}
                    </li>
                ))}
            </ul>

            <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '1rem', marginTop: '2rem' }}>
                <button onClick={handleFinishAndClear} className="btn" style={{ backgroundColor: 'var(--secondary-color)', color: 'white' }}>
                    Terminé
                </button>
                <button onClick={handleSubmit} className="btn btn-primary" disabled={isUploading || waitingCount === 0}>
                    {isUploading ? 'Traitement en cours...' : `Lancer le traitement (${waitingCount})`}
                </button>
            </div>
        </div>
    );
}

function CrudManager({ title, endpoint, token, user, fields, filterConfig }) {
    const [items, setItems] = useState([]);
    const [editingItem, setEditingItem] = useState(null);
    const [isCreating, setIsCreating] = useState(false);
    const [filters, setFilters] = useState({});
    const [showOcrUploader, setShowOcrUploader] = useState(false);
    const [dynamicDestinations, setDynamicDestinations] = useState([]);
    const [selectedItems, setSelectedItems] = useState([]);
    const selectAllCheckboxRef = useRef(null);

    const [modalState, setModalState] = useState({ isOpen: false, title: '', message: '', onConfirm: () => { } });
    const [notification, setNotification] = useState({ message: '', type: '' });

    const showNotification = (message, type = 'error') => {
        setNotification({ message, type });
    };

    const fetchDestinationsForUser = useCallback(async (userId) => {
        const query = userId ? `?user_id=${userId}` : '';
        try {
            const response = await fetch(`${API_URL}/destinations/${query}`, { headers: { 'Authorization': `Bearer ${token}` } });
            if (response.ok) setDynamicDestinations(await response.json());
        } catch (error) { console.error("Échec de la récupération des destinations:", error); }
    }, [token]);

    useEffect(() => { if (user.role === 'admin' && endpoint === 'passports') fetchDestinationsForUser(null); }, [user, endpoint, fetchDestinationsForUser]);

    const handleFilterChange = (filterName, value) => {
        const newFilters = { ...filters, [filterName]: value };
        if (user.role === 'admin' && filterName === 'user_filter') {
            fetchDestinationsForUser(value || null);
            newFilters.voyage_filter = '';
        }
        setFilters(newFilters);
    };

    const fetchData = useCallback(async () => {
        const activeFilters = Object.fromEntries(Object.entries(filters).filter(([, v]) => v));
        const query = new URLSearchParams(activeFilters);
        const url = `${API_URL}/${endpoint}/?${query.toString()}`;
        try {
            const response = await fetch(url, { headers: { 'Authorization': `Bearer ${token}` } });
            if (response.ok) setItems(await response.json());
            else console.error("Échec de la récupération des données pour", endpoint);
        } catch (error) { console.error("Erreur lors de la récupération des données:", error); }
    }, [endpoint, token, filters]);

    useEffect(() => { fetchData(); }, [fetchData]);

    useEffect(() => {
        if (selectAllCheckboxRef.current) {
            const allVisibleSelected = items.length > 0 && selectedItems.length === items.length;
            const someVisibleSelected = selectedItems.length > 0 && selectedItems.length < items.length;
            selectAllCheckboxRef.current.checked = allVisibleSelected;
            selectAllCheckboxRef.current.indeterminate = someVisibleSelected;
        }
    }, [selectedItems, items]);

    const handleSelect = (id) => setSelectedItems(prev => prev.includes(id) ? prev.filter(itemId => itemId !== id) : [...prev, id]);
    const handleSelectAll = (e) => setSelectedItems(e.target.checked ? items.map(item => item.id) : []);

    const confirmMultipleDelete = () => {
        if (selectedItems.length === 0) return;
        setModalState({
            isOpen: true,
            title: 'Confirmer la Suppression',
            message: `Êtes-vous sûr de vouloir supprimer les ${selectedItems.length} passeports sélectionnés ? Cette action est irréversible.`,
            onConfirm: () => handleMultipleDelete()
        });
    };

    const handleMultipleDelete = async () => {
        try {
            const response = await fetch(`${API_URL}/${endpoint}/delete-multiple`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                body: JSON.stringify({ ids: selectedItems }),
            });
            if (response.ok || response.status === 204) {
                setSelectedItems([]);
                fetchData();
            } else {
                const errorData = await response.json();
                showNotification(`Échec de la suppression : ${errorData.detail || 'Erreur du serveur'}`);
            }
        } catch (error) {
            console.error("Erreur lors de la suppression multiple :", error);
            showNotification("Une erreur de réseau est survenue lors de la suppression.");
        } finally {
            setModalState({ isOpen: false, title: '', message: '', onConfirm: () => { } });
        }
    };

    const handleSave = (fromOcr = false) => {
        if (!fromOcr) {
            setEditingItem(null);
            setIsCreating(false);
            setShowOcrUploader(false);
        }
        fetchData();
    };

    const startCreating = () => {
        let newItem = Object.keys(fields).reduce((acc, key) => ({ ...acc, [key]: '' }), {});
        if (endpoint === 'admin/users') newItem.role = 'user';
        if (endpoint === 'admin/invitations') newItem = { email: '' };
        setEditingItem(newItem);
        setIsCreating(true);
    };

    if (showOcrUploader) return <OcrUploader token={token} onUploadSuccess={handleSave} />
    if (editingItem) return <CrudForm item={editingItem} isCreating={isCreating} onSave={handleSave} onCancel={() => setEditingItem(null)} fields={fields} endpoint={endpoint} token={token} />;
    const displayFields = { ...fields };
    if (endpoint === 'admin/users') delete displayFields.password;
    if (endpoint === 'admin/invitations' && isCreating) delete displayFields.token;
    if (endpoint === 'passports') delete displayFields.destination;

    return (
        <div>
            <Notification message={notification.message} type={notification.type} onClear={() => setNotification({ message: '', type: '' })} />
            <Modal isOpen={modalState.isOpen} onClose={() => setModalState({ ...modalState, isOpen: false })} onConfirm={modalState.onConfirm} title={modalState.title}>
                <p>{modalState.message}</p>
            </Modal>

            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }} className="mb-2">
                <h2>{title}</h2>
                <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
                    {endpoint === 'passports' && (
                        <button onClick={confirmMultipleDelete} className="btn btn-danger" disabled={selectedItems.length === 0}>
                            Supprimer ({selectedItems.length})
                        </button>
                    )}
                    {endpoint === 'passports' && (
                        <button onClick={() => setShowOcrUploader(true)} className="btn btn-primary" style={{ backgroundColor: 'var(--success-color)' }}>+ Ajouter par Téléchargement</button>
                    )}
                    <button onClick={startCreating} className="btn btn-primary">{endpoint === 'passports' ? '+ Ajouter Manuellement' : '+ Ajouter'}</button>
                </div>
            </div>

            {endpoint.includes('users') && !filterConfig && (<div className="filter-bar mb-2"><div className="form-group" style={{ flex: 1, marginBottom: 0 }}><input type="text" name="name_filter" placeholder="Filtrer par Nom, Nom d'utilisateur ou Email" onChange={(e) => handleFilterChange(e.target.name, e.target.value)} className="form-input" autoComplete="off"/></div></div>)}
            {filterConfig && (
                <div className="filter-bar mb-2">
                    {filterConfig.map(filter => (<ComboBoxFilter key={filter.name} {...filter} onChange={handleFilterChange} />))}
                    {user.role === 'admin' && endpoint === 'passports' && (<ComboBoxFilter key="voyage_filter" name="voyage_filter" placeholder="Filtrer par Destination" options={dynamicDestinations.map(d => ({ destination: d }))} getOptionValue={(o) => o.destination} getOptionLabel={(o) => o.destination} onChange={handleFilterChange} />)}
                </div>
            )}

            <div className="table-container">
                <table className="table">
                    <thead>
                        <tr>
                            {endpoint === 'passports' && (<th style={{ width: '1%' }}><input type="checkbox" ref={selectAllCheckboxRef} className="form-checkbox" onChange={handleSelectAll} disabled={items.length === 0}/></th>)}
                            {Object.keys(displayFields).map(field => (<th key={field}>{columnTranslations[field] || field.replace(/_/g, ' ')}</th>))}
                            <th>{columnTranslations['actions']}</th>
                        </tr>
                    </thead>
                    <tbody>
                        {items.map(item => (
                            <tr key={item.id} style={{ backgroundColor: selectedItems.includes(item.id) ? '#eef2f7' : 'transparent' }}>
                                {endpoint === 'passports' && (<td><input type="checkbox" className="form-checkbox" checked={selectedItems.includes(item.id)} onChange={() => handleSelect(item.id)}/></td>)}
                                {Object.keys(displayFields).map(field => {
                                    let cellValue = item[field];
                                    if (field === 'confidence_score' && typeof cellValue === 'number') { cellValue = `${(cellValue * 100).toFixed(2)}%`; }
                                    return <td key={field}>{String(cellValue)}</td>
                                })}
                                <td>
                                    <button onClick={() => setEditingItem(item)} className="btn" style={{ backgroundColor: 'var(--warning-color)', color: 'black', marginRight: '0.5rem' }}>Modifier</button>
                                    {endpoint !== 'passports' && <button onClick={() => {/* Implement single delete with modal if needed */}} className="btn btn-danger">Supprimer</button>}
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );
}

function CrudForm({ item, isCreating, onSave, onCancel, fields, endpoint, token }) {
    const [formData, setFormData] = useState(item);
    const [destinations, setDestinations] = useState([]);
    const [error, setError] = useState('');
    useEffect(() => {
        const initialData = { ...item };
        Object.entries(fields).forEach(([key, type]) => { if (type === 'datetime-local' && initialData[key]) { initialData[key] = new Date(initialData[key]).toISOString().slice(0, 16); } });
        if (endpoint === 'passports' && !isCreating && item.voyages && item.voyages.length > 0) { initialData.destination = item.voyages[0].destination; }
        setFormData(initialData);
    }, [item, fields, endpoint, isCreating]);
    
    useEffect(() => {
        if (endpoint === 'passports') {
            const fetchDestinations = async () => {
                try {
                    const response = await fetch(`${API_URL}/destinations/`, { headers: { 'Authorization': `Bearer ${token}` } });
                    if (response.ok) setDestinations(await response.json());
                } catch (error) { console.error("Échec de la récupération des destinations:", error); }
            };
            fetchDestinations();
        }
    }, [endpoint, token]);

    const handleChange = (e) => { const { name, value, type, checked } = e.target; setFormData({ ...formData, [name]: type === 'checkbox' ? checked : value }); };
    const handleSubmit = async (e) => {
        e.preventDefault(); setError('');
        let url = isCreating ? `${API_URL}/${endpoint}/` : `${API_URL}/${endpoint}/${item.id}`;
        let method = isCreating ? 'POST' : 'PUT';
        let body = { ...formData };
        if (body.confidence_score === '') { body.confidence_score = null; }
        if (endpoint === 'admin/invitations' && isCreating) body = { email: formData.email };
        if (endpoint === 'admin/users' && !isCreating && !body.password) delete body.password;
        const response = await fetch(url, { method, headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` }, body: JSON.stringify(body), });
        if (response.ok) { onSave(); } else { const errorData = await response.json(); setError(errorData.detail || "Échec de l'enregistrement de l'élément."); }
    };
    const formFields = { ...fields };
    if (formFields.confidence_score) { delete formFields.confidence_score; }
    if (isCreating && endpoint === 'admin/invitations') { return (<form onSubmit={handleSubmit} className="form-container" style={{ maxWidth: 'none', margin: 0, padding: '2rem' }}><h3>Créer une nouvelle invitation</h3>{error && <p className="error-message">{error}</p>}<div className="form-group"><label>Email</label><input type="email" name="email" value={formData.email || ''} onChange={handleChange} className="form-input" required /></div><div style={{ display: 'flex', justifyContent: 'flex-end', gap: '1rem', marginTop: '2rem' }}><button type="button" onClick={onCancel} className="btn" style={{ backgroundColor: 'var(--secondary-color)', color: 'white' }}>Annuler</button><button type="submit" className="btn btn-primary">Enregistrer</button></div></form>) }
    return (<form onSubmit={handleSubmit} className="form-container" style={{ maxWidth: 'none', margin: 0, padding: '2rem' }}><h3>{isCreating ? 'Créer' : 'Modifier'} l'élément</h3>{error && <p className="error-message">{error}</p>}<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>{Object.entries(formFields).map(([key, type]) => (<div className="form-group" key={key}><label>{columnTranslations[key] || key.replace(/_/g, ' ')}</label>{key === 'password' ? (<PasswordInput name={key} value={formData[key] || ''} onChange={handleChange} placeholder={!isCreating ? 'Laisser vide pour conserver' : ''} required={isCreating} />) : key === 'destination' ? (<><input type="text" name="destination" value={formData.destination || ''} onChange={handleChange} className="form-input" list="destination-datalist-form" placeholder="Choisissez ou créez une destination" autoComplete="off" /><datalist id="destination-datalist-form">{destinations.map(dest => <option key={dest} value={dest} />)}</datalist></>) : type === 'checkbox' ? (<input type="checkbox" name={key} checked={!!formData[key]} onChange={handleChange} className="form-checkbox" />) : (<input type={type} name={key} value={formData[key] || ''} onChange={handleChange} className="form-input" required={key !== 'destination' && key !== 'token' && type !== 'checkbox'} readOnly={(key === 'token')} />)}</div>))}</div><div style={{ display: 'flex', justifyContent: 'flex-end', gap: '1rem', marginTop: '2rem' }}><button type="button" onClick={onCancel} className="btn" style={{ backgroundColor: 'var(--secondary-color)', color: 'white' }}>Annuler</button><button type="submit" className="btn btn-primary">Enregistrer</button></div></form>);
}

function ToolsAndExportPanel({ token, user, adminUsers, userDestinations }) {
    const [filters, setFilters] = useState({ user_id: '', destination: '' });
    const [previewData, setPreviewData] = useState(null);
    const [inviteEmail, setInviteEmail] = useState('');
    const [inviteMsg, setInviteMsg] = useState('');
    const [invitationLink, setInvitationLink] = useState('');
    const [notification, setNotification] = useState({ message: '', type: '' });

    const showNotification = (message, type = 'error') => { setNotification({ message, type }); };
    const handleFilterChange = (name, value) => { setFilters(prev => ({ ...prev, [name]: value })); setPreviewData(null); };

    const getFilteredData = async () => {
        const activeFilters = Object.fromEntries(Object.entries(filters).filter(([, v]) => v));
        if (user.role !== 'admin') delete activeFilters.user_id;
        const query = new URLSearchParams(activeFilters).toString();
        try {
            const response = await fetch(`${API_URL}/export/data?${query}`, { headers: { 'Authorization': `Bearer ${token}` } });
            if (!response.ok) {
                const err = await response.json();
                showNotification(`Échec de la récupération des données: ${err.detail}`);
                return null;
            }
            return response;
        } catch (error) { showNotification('Une erreur est survenue lors de la récupération des données.'); return null; }
    };

    const handlePreview = async () => {
        const response = await getFilteredData();
        if (response) {
            const csvText = await response.text();
            if (!csvText) { setPreviewData([]); return; }
            const rows = csvText.trim().split('\n');
            const headers = rows[0].split(',');
            const data = rows.slice(1).map(row => { const values = row.split(','); return headers.reduce((obj, h, i) => ({ ...obj, [h]: values[i] }), {}); });
            setPreviewData(data);
        }
    };

    const handleExport = async () => {
        const response = await getFilteredData();
        if (response) {
            const blob = await response.blob();
            const contentDisposition = response.headers.get('content-disposition');
            const filename = contentDisposition?.match(/filename="?(.+)"?/)?.[1] || 'passports_export.csv';
            const url = window.URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
            setPreviewData(null);
        }
    };

    const handleInvite = async () => {
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(inviteEmail)) { setInviteMsg('Veuillez entrer une adresse email valide.'); return; }
        setInviteMsg('Génération du lien...'); setInvitationLink('');
        try {
            const response = await fetch(`${API_URL}/admin/invitations`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` }, body: JSON.stringify({ email: inviteEmail }), });
            const data = await response.json();
            if (response.ok) { const link = `${window.location.origin}/register/${data.token}`; setInvitationLink(link); setInviteMsg('Lien généré. Copiez-le et envoyez-le à l\'utilisateur.'); } else { setInviteMsg(data.detail || 'Échec de la création de l\'invitation.'); }
        } catch (error) { setInviteMsg('Une erreur est survenue.'); }
    };

    return (
        <div>
            <Notification message={notification.message} type={notification.type} onClear={() => setNotification({ message: '', type: '' })} />
            <h2>Outils & Exportation</h2>
            {user.role === 'admin' && (
                <div className="form-container" style={{ maxWidth: 'none', margin: 0, padding: '2rem', marginBottom: '2rem' }}>
                    <h3>Inviter un nouvel utilisateur</h3>
                    <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
                        <input type="email" placeholder="Entrez l'email de l'utilisateur" value={inviteEmail} onChange={e => setInviteEmail(e.target.value)} className="form-input" style={{ flexGrow: 1 }} />
                        <button onClick={handleInvite} className="btn btn-primary" style={{ backgroundColor: 'var(--warning-color)', color: 'black' }}>Générer le lien</button>
                    </div>
                    {inviteMsg && <p className="info-message mt-1">{inviteMsg}</p>}
                    {invitationLink && (<div className="mt-1"><input type="text" readOnly value={invitationLink} className="form-input" onClick={e => e.target.select()} /></div>)}
                </div>
            )}
            <div className="form-container" style={{ maxWidth: 'none', margin: 0, padding: '2rem' }}>
                <h3>Filtrer et Exporter les Données des Passeports</h3>
                <div className="filter-bar mb-1">
                    {user.role === 'admin' && (<ComboBoxFilter name="user_id" placeholder="Filtrer par Utilisateur" options={adminUsers} getOptionValue={(o) => o.id} getOptionLabel={(o) => `${o.first_name} ${o.last_name} (${o.user_name})`} onChange={handleFilterChange} />)}
                    <ComboBoxFilter name="destination" placeholder="Filtrer par Destination" options={userDestinations.map(d => ({ destination: d }))} getOptionValue={(o) => o.destination} getOptionLabel={(o) => o.destination} onChange={handleFilterChange} />
                </div>
                <button onClick={handlePreview} className="btn btn-primary">Aperçu des Données</button>
                {previewData && (<><PreviewTable data={previewData} /><button onClick={handleExport} className="btn mt-1" style={{ backgroundColor: 'var(--success-color)', color: 'white' }}>Télécharger en CSV</button></>)}
            </div>
        </div>
    );
}

function ComboBoxFilter({ name, placeholder, options, getOptionValue, getOptionLabel, onChange }) {
    const dataListId = `datalist-${name}-${Math.random()}`;
    return (
        <div className="form-group" style={{ flex: 1, marginBottom: 0 }}>
            <input list={dataListId} name={name} placeholder={placeholder} onChange={(e) => onChange(name, e.target.value)} className="form-input" autoComplete="off" />
            <datalist id={dataListId}>
                <option value="">-- Aucun --</option>
                {options.map(option => (<option key={getOptionValue(option)} value={getOptionValue(option)}>{getOptionLabel(option)}</option>))}
            </datalist>
        </div>
    );
}

function PreviewTable({ data }) {
    if (!data || data.length === 0) return <p className="mt-2 text-center info-message">Aucune donnée à prévisualiser pour les filtres sélectionnés.</p>;
    const headers = Object.keys(data[0]);
    return (<div className="mt-2"><h3 className="mb-1">Aperçu des Données</h3><div className="table-container"><table className="table"><thead><tr>{headers.map(h => <th key={h}>{columnTranslations[h] || h.replace(/_/g, ' ')}</th>)}</tr></thead><tbody>{data.map((row, i) => <tr key={i}>{headers.map(h => <td key={h}>{String(row[h])}</td>)}</tr>)}</tbody></table></div></div>);
}

# --------------- END OF FILE: frontend/src/App.jsx ---------------

# --------------- START OF FILE: frontend/Dockerfile ---------------

# frontend/Dockerfile

# Stage 1: Build the React application
FROM node:18-alpine as builder

WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
# Set the API URL during the build
# Although we are using a proxy, it's good practice
# to set it for consistency if needed elsewhere.
ARG VITE_API_URL=/api
RUN npm run build

# Stage 2: Serve the application with Nginx
FROM nginx:1.21.0-alpine

# Copy the built files from the builder stage
COPY --from=builder /app/dist /usr/share/nginx/html

# Remove the default Nginx configuration
RUN rm /etc/nginx/conf.d/default.conf

# Copy our custom Nginx configuration
COPY nginx.conf /etc/nginx/conf.d

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]


# --------------- END OF FILE: frontend/Dockerfile ---------------

# --------------- START OF FILE: frontend/nginx.conf ---------------

# frontend/nginx.conf

server {
  listen 80;
  server_name localhost;
  client_max_body_size 50M;
  location / {
    root   /usr/share/nginx/html;
    index  index.html index.htm;
    try_files $uri $uri/ /index.html;
  }

  # This is the new part!
  # It proxies any request starting with /api
  # to the backend service.
  location /api/ {
    # The name 'backend' comes from your docker-compose service name.
    proxy_pass http://backend:8000/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
  }

  error_page   500 502 503 504  /50x.html;
  location = /50x.html {
    root   /usr/share/nginx/html;
  }
}


# --------------- END OF FILE: frontend/nginx.conf ---------------

# --------------- START OF FILE: docker-compose.yml ---------------

services:
  # --- NGINX (Frontend Service) ---
  nginx:
    # This can remain a build context as it depends on the nginx.conf from the repo
    build:
      context: ./frontend
    # Or, for consistency, you can use the image you pushed
    # image: your-dockerhub-username/fastreact-frontend:latest
    ports:
      - "80:80" # Expose HTTP port to the world
    depends_on:
      - backend

  # --- FASTAPI (Backend Service) ---
  backend:
    # Use the image from Docker Hub instead of building on the server
    image: your-dockerhub-username/fastreact-backend:latest
    # Do NOT expose ports to the host. Nginx will proxy to it.
    volumes:
      # Mount the credentials file into the container (read-only)
      - ./google-credentials.json:/app/google-credentials.json:ro
    env_file:
      - ./.env.prod # Load production environment variables
    depends_on:
      - redis

  # --- REDIS (Message Broker) ---
  redis:
    image: "redis:7-alpine"
    # No ports exposed to the host, only accessible within the Docker network.

  # --- CELERY (Worker Service) ---
  worker:
    # Use the same backend image from Docker Hub
    image: your-dockerhub-username/fastreact-backend:latest
    command: ["celery", "-A", "celery_worker.celery_app", "worker", "--loglevel=info"]
    volumes:
      # Mount the credentials file into the container (read-only)
      - ./google-credentials.json:/app/google-credentials.json:ro
    env_file:
      - ./.env.prod
    depends_on:
      - redis
      - backend

# --------------- END OF FILE: docker-compose.yml ---------------

