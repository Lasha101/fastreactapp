# --------------- START OF FILE: backend/main.py ---------------

# backend/main.py
import base64
import os
import pandas as pd
from contextlib import asynccontextmanager
import tempfile
from fastapi import BackgroundTasks
from pydantic import ValidationError
from fastapi import FastAPI, Depends, HTTPException, status, UploadFile, File, Query, Form, Request, Response, Body
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse, JSONResponse
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
import io
from datetime import datetime, timezone
import crud, models, schemas, auth
from database import SessionLocal, engine, get_db
from typing import Optional, List
import ocr_service 
from celery.result import AsyncResult
from celery_worker import celery_app, extract_document_data
import logging 

from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
from dotenv import load_dotenv

# Load environment variables from a .env file (for local development)
load_dotenv()

# CONFIGURE logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# INITIALIZE the limiter to identify users by their IP address
limiter = Limiter(key_func=get_remote_address)


# --- CORRECT STARTUP LOGIC ---
# Define UPLOAD_DIR here so it's accessible globally
UPLOAD_DIR = "uploads"

# Lifespan manager to handle startup events like creating directories.
@asynccontextmanager
async def lifespan(app: FastAPI):
    # This code runs once on application startup.
    logger.info("Application startup...")
    # Create the upload directory, but don't fail if it already exists.
    os.makedirs(UPLOAD_DIR, exist_ok=True)
    logger.info(f"Ensured upload directory '{UPLOAD_DIR}' exists.")
    
    yield
    
    # This code runs on shutdown.
    logger.info("Application shutdown.")


app = FastAPI(lifespan=lifespan)

# SET the limiter on the app state and add the exception handler
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)


# --- CORS Middleware ---
origins = ["*"]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
    expose_headers=["Content-Disposition"],
)

# --- Authentication Routes ---
@app.post("/token", response_model=schemas.Token)
@limiter.limit("5/minute")
def login_for_access_token(request: Request, form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = auth.authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Nom d'utilisateur ou mot de passe incorrect",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token = auth.create_access_token(data={"sub": user.user_name})
    return {"access_token": access_token, "token_type": "bearer"}

# --- User Routes ---
@app.post("/users/", response_model=schemas.User)
def register_user(user: schemas.UserCreate, token: str = Query(...), db: Session = Depends(get_db)):
    invitation = crud.get_invitation_by_token(db, token)
    if not invitation or invitation.is_used or invitation.expires_at.replace(tzinfo=timezone.utc) < datetime.now(timezone.utc):
        raise HTTPException(status_code=400, detail="Jeton d'inscription invalide ou expiré.")

    if invitation.email != user.email:
        raise HTTPException(status_code=400, detail="L'email d'inscription ne correspond pas à l'email de l'invitation.")

    db_user_by_email = crud.get_user_by_email(db, email=user.email)
    if db_user_by_email:
        raise HTTPException(status_code=400, detail="Email déjà enregistré")

    db_user_by_username = crud.get_user_by_username(db, username=user.user_name)
    if db_user_by_username:
        raise HTTPException(status_code=400, detail="Nom d'utilisateur déjà enregistré")

    created_user = crud.create_user(db=db, user=user, role="user")
    
    db.delete(invitation)
    db.commit()

    return created_user

@app.get("/users/me", response_model=schemas.User)
def read_users_me(current_user: models.User = Depends(auth.get_current_active_user)):
    return current_user

@app.put("/users/me", response_model=schemas.User)
def update_user_me(user_update: schemas.UserUpdate, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    return crud.update_user(db=db, user_id=current_user.id, user_update=user_update)

@app.get("/admin/users/", response_model=list[schemas.User], dependencies=[Depends(auth.require_admin)])
def read_users(
    skip: int = 0,
    limit: int = 100,
    name_filter: Optional[str] = Query(None),
    db: Session = Depends(get_db)
):
    users = crud.get_users(db, skip=skip, limit=limit, name_filter=name_filter)
    return users

@app.delete("/admin/users/{user_id}", response_model=schemas.User, dependencies=[Depends(auth.require_admin)])
def delete_user(user_id: int, db: Session = Depends(get_db)):
    db_user = crud.delete_user(db=db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvé")
    return db_user

@app.get("/admin/users/{user_id}", response_model=schemas.User, dependencies=[Depends(auth.require_admin)])
def read_user(user_id: int, db: Session = Depends(get_db)):
    db_user = crud.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvé")
    return db_user

@app.put("/admin/users/{user_id}", response_model=schemas.User, dependencies=[Depends(auth.require_admin)])
def update_user(user_id: int, user_update: schemas.UserUpdate, db: Session = Depends(get_db)):
    db_user = crud.update_user(db=db, user_id=user_id, user_update=user_update)
    if db_user is None:
        raise HTTPException(status_code=404, detail="Utilisateur non trouvé")
    return db_user

@app.post("/admin/users/", response_model=schemas.User, dependencies=[Depends(auth.require_admin)])
def create_user_by_admin(user: schemas.UserCreate, db: Session = Depends(get_db)):
    db_user_by_email = crud.get_user_by_email(db, email=user.email)
    if db_user_by_email:
        raise HTTPException(status_code=400, detail="Email déjà enregistré")

    db_user_by_username = crud.get_user_by_username(db, username=user.user_name)
    if db_user_by_username:
        raise HTTPException(status_code=400, detail="Nom d'utilisateur déjà enregistré")

    return crud.create_user(db=db, user=user, role=user.role if hasattr(user, 'role') else 'user')

# --- Passport Routes ---
@app.post("/passports/", response_model=schemas.Passport)
def create_passport(passport: schemas.PassportCreate, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    return crud.create_user_passport(db=db, passport=passport, user_id=current_user.id)

@app.post("/passports/upload-and-extract/", response_model=schemas.MultiAsyncTaskResponse, status_code=status.HTTP_202_ACCEPTED)
async def upload_and_extract_passport_async(
    destination: Optional[str] = Form(None),
    files: List[UploadFile] = File(...),
    current_user: models.User = Depends(auth.get_current_active_user)
):
    task_ids = []
    for file in files:
        try:
            # Read file content into memory instead of saving to a temp file
            content = await file.read()
            encoded_content = base64.b64encode(content).decode('utf-8')
            # Pass the raw content to the Celery worker
            task = extract_document_data.delay(
                file_content=encoded_content,
                original_filename=file.filename,
                content_type=file.content_type,
                destination=destination,
                user_id=current_user.id
            )
            task_ids.append({"task_id": task.id, "filename": file.filename})

        except Exception as e:
            logger.error(f"Could not read uploaded file: {file.filename}. Error: {e}")
            continue

    if not task_ids:
        raise HTTPException(status_code=500, detail="No files could be processed.")

    return JSONResponse(content={"tasks": task_ids}, status_code=status.HTTP_202_ACCEPTED)

@app.get("/tasks/{task_id}/status", response_model=schemas.AsyncTaskStatus)
def get_task_status(task_id: str):
    task_result = AsyncResult(task_id, app=celery_app)
    
    response_data = {
        "task_id": task_id,
        "status": task_result.status,
        "progress": None,
        "result": None
    }
    
    if task_result.status == 'SUCCESS':
        response_data["result"] = task_result.result
    elif task_result.status == 'FAILURE':
        response_data["result"] = str(task_result.info)
    elif task_result.status == 'PROGRESS':
        response_data["progress"] = task_result.info if isinstance(task_result.info, dict) else {"status": str(task_result.info)}
    elif task_result.status == 'REVOKED':
        response_data['status'] = 'CANCELLED'
        response_data['progress'] = {'status': 'Task was cancelled.'}

    return response_data

@app.post("/tasks/{task_id}/cancel", status_code=status.HTTP_202_ACCEPTED)
def cancel_task(task_id: str):
    logger.info(f"Received request to cancel task: {task_id}")
    celery_app.control.revoke(task_id, terminate=True, signal='SIGTERM')
    return JSONResponse(content={"message": "Cancellation request sent."}, status_code=202)

@app.get("/export/data")
def export_data(
    destination: Optional[str] = None,
    user_id: Optional[int] = None,
    first_name: Optional[str] = None,
    last_name: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: models.User = Depends(auth.get_current_active_user)
):
    effective_user_id = current_user.id
    if current_user.role == "admin":
        effective_user_id = user_id
    
    filtered_data = crud.filter_data(db, destination, effective_user_id, first_name, last_name)
    
    if not filtered_data:
        raise HTTPException(status_code=404, detail="Aucune donnée de passeport trouvée pour les critères donnés")
    
    df = pd.DataFrame(filtered_data)
    stream = io.StringIO()
    df.to_csv(stream, index=False)
    
    filename_parts = ["passeports"]
    if destination:
        filename_parts.append(destination.replace(' ', '_').lower())

    if current_user.role == 'admin':
        if user_id:
            filtered_user = crud.get_user(db, user_id)
            if filtered_user:
                filename_parts.append(f"pour_{filtered_user.user_name.lower()}")
            else:
                filename_parts.append(f"pour_utilisateur_{user_id}")
        else:
            filename_parts.append("rapport")
    else:
        filename_parts.append(f"pour_{current_user.user_name.lower()}")

    filename = f"{'_'.join(filename_parts)}.csv"
        
    response = StreamingResponse(iter([stream.getvalue()]), media_type="text/csv")
    response.headers["Content-Disposition"] = f"attachment; filename={filename}"
    return response

@app.get("/passports/", response_model=list[schemas.Passport])
def read_passports(
    db: Session = Depends(get_db),
    current_user: models.User = Depends(auth.get_current_active_user),
    user_filter: Optional[str] = None,
    voyage_filter: Optional[str] = None
):
    if current_user.role == "admin":
        return crud.get_passports(db=db, user_filter=user_filter, voyage_filter=voyage_filter)
    return crud.get_passports_by_user(db=db, user_id=current_user.id)

@app.put("/passports/{passport_id}", response_model=schemas.Passport)
def update_passport(passport_id: int, passport_update: schemas.PassportCreate, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    db_passport = crud.get_passport(db, passport_id=passport_id)
    if db_passport is None:
        raise HTTPException(status_code=404, detail="Passeport non trouvé")
    if current_user.role != "admin" and db_passport.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Non autorisé à mettre à jour ce passeport")
    return crud.update_passport(db=db, passport_id=passport_id, passport_update=passport_update)

@app.delete("/passports/{passport_id}", response_model=schemas.Passport)
def delete_passport(passport_id: int, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    db_passport = crud.get_passport(db, passport_id=passport_id)
    if db_passport is None:
        raise HTTPException(status_code=404, detail="Passeport non trouvé")
    if current_user.role != "admin" and db_passport.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Non autorisé à supprimer ce passeport")
    return crud.delete_passport(db=db, passport_id=passport_id)

@app.post("/passports/delete-multiple", status_code=status.HTTP_204_NO_CONTENT, summary="Delete multiple passports")
def delete_multiple_passports(
    payload: schemas.IdsList = Body(...),
    db: Session = Depends(get_db),
    current_user: models.User = Depends(auth.get_current_active_user)
):
    if not payload.ids:
        return Response(status_code=status.HTTP_204_NO_CONTENT)

    crud.delete_passports_by_ids(
        db=db,
        passport_ids=payload.ids,
        user_id=current_user.id,
        is_admin=(current_user.role == 'admin')
    )
    
    return Response(status_code=status.HTTP_204_NO_CONTENT)

# --- Voyage Routes ---
@app.post("/voyages/", response_model=schemas.Voyage)
def create_voyage(voyage: schemas.VoyageCreate, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    return crud.create_user_voyage(db=db, voyage=voyage, user_id=current_user.id, passport_ids=voyage.passport_ids)

@app.get("/voyages/", response_model=list[schemas.Voyage])
def read_voyages(
    db: Session = Depends(get_db),
    current_user: models.User = Depends(auth.get_current_active_user),
    user_filter: Optional[str] = None
):
    if current_user.role == "admin":
        return crud.get_voyages(db=db, user_filter=user_filter)
    return crud.get_voyages_by_user(db=db, user_id=current_user.id)

@app.put("/voyages/{voyage_id}", response_model=schemas.Voyage)
def update_voyage(voyage_id: int, voyage_update: schemas.VoyageCreate, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    db_voyage = crud.get_voyage(db, voyage_id=voyage_id)
    if db_voyage is None:
        raise HTTPException(status_code=404, detail="Voyage non trouvé")
    if current_user.role != "admin" and db_voyage.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Non autorisé à mettre à jour ce voyage")
    return crud.update_voyage(db=db, voyage_id=voyage_id, voyage_update=voyage_update)

@app.delete("/voyages/{voyage_id}", response_model=schemas.Voyage)
def delete_voyage(voyage_id: int, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_active_user)):
    db_voyage = crud.get_voyage(db, voyage_id=voyage_id)
    if db_voyage is None:
        raise HTTPException(status_code=404, detail="Voyage non trouvé")
    if current_user.role != "admin" and db_voyage.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Non autorisé à supprimer ce voyage")
    return crud.delete_voyage(db=db, voyage_id=voyage_id)

@app.get("/destinations/", response_model=List[str])
def get_unique_destinations(
    user_id: Optional[int] = Query(None),
    db: Session = Depends(get_db),
    current_user: models.User = Depends(auth.get_current_active_user)
):
    target_user_id = current_user.id
    if current_user.role == "admin" and user_id is not None:
        target_user_id = user_id
    
    return crud.get_destinations_by_user_id(db, user_id=target_user_id)

# --- File Upload Route ---
@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile = File(...), current_user: models.User = Depends(auth.get_current_active_user)):
    file_location = os.path.join(UPLOAD_DIR, f"{current_user.user_name}_{file.filename}")
    with open(file_location, "wb+") as file_object:
        file_object.write(file.file.read())
    return {"info": f"fichier '{file.filename}' sauvegardé à '{file_location}'"}

@app.get("/invitations/{token}", response_model=schemas.Invitation)
def get_invitation(token: str, db: Session = Depends(get_db)):
    invitation = crud.get_invitation_by_token(db, token)
    if not invitation or invitation.is_used or invitation.expires_at.replace(tzinfo=timezone.utc) < datetime.now(timezone.utc):
        raise HTTPException(status_code=404, detail="Invitation non trouvée ou invalide.")
    return invitation

# --- Admin-specific Routes ---
@app.post("/admin/invitations", response_model=schemas.Invitation, dependencies=[Depends(auth.require_admin)])
def create_invitation(invitation: schemas.InvitationCreate, db: Session = Depends(get_db)):
    existing_user = crud.get_user_by_email(db, email=invitation.email)
    if existing_user:
        raise HTTPException(status_code=400, detail="Un utilisateur avec cet email existe déjà.")

    existing_invitation = crud.get_invitation_by_email(db, email=invitation.email)
    if existing_invitation and not existing_invitation.is_used:
        raise HTTPException(status_code=400, detail="Une invitation active pour cet email existe déjà.")
    
    return crud.create_invitation(db=db, email=invitation.email)

@app.get("/admin/invitations/", response_model=list[schemas.Invitation], dependencies=[Depends(auth.require_admin)])
def read_invitations(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    invitations = crud.get_invitations(db, skip=skip, limit=limit)
    return invitations

@app.put("/admin/invitations/{invitation_id}", response_model=schemas.Invitation, dependencies=[Depends(auth.require_admin)])
def update_invitation(invitation_id: int, invitation_update: schemas.InvitationUpdate, db: Session = Depends(get_db)):
    db_invitation = crud.update_invitation(db=db, invitation_id=invitation_id, invitation_update=invitation_update)
    if db_invitation is None:
        raise HTTPException(status_code=404, detail="Invitation non trouvée")
    return db_invitation

@app.delete("/admin/invitations/{invitation_id}", response_model=schemas.Invitation, dependencies=[Depends(auth.require_admin)])
def delete_invitation(invitation_id: int, db: Session = Depends(get_db)):
    db_invitation = crud.delete_invitation(db=db, invitation_id=invitation_id)
    if db_invitation is None:
        raise HTTPException(status_code=404, detail="Invitation non trouvée")
    return db_invitation

@app.get("/admin/filterable-users", response_model=list[schemas.User], dependencies=[Depends(auth.require_admin)])
def read_filterable_users(db: Session = Depends(get_db)):
    return crud.get_all_users_for_filtering(db)

# --------------- END OF FILE: backend/main.py ---------------

# --------------- START OF FILE: backend/crud.py ---------------



# /crud.py

from sqlalchemy.orm import Session, joinedload, outerjoin
import models, schemas, auth
import secrets
from datetime import datetime, timedelta, timezone
from typing import Optional, List
from fastapi import HTTPException
from http import HTTPStatus

def get_user(db: Session, user_id: int):
    return db.query(models.User).filter(models.User.id == user_id).first()
def get_user_by_username(db: Session, username: str):
    return db.query(models.User).filter(models.User.user_name == username).first()
def get_user_by_email(db: Session, email: str):
    return db.query(models.User).filter(models.User.email == email).first()
def get_users(db: Session, skip: int = 0, limit: int = 100, name_filter: Optional[str] = None):
    # Exclude the admin user from the list of manageable users
    query = db.query(models.User).filter(models.User.user_name != "admin")
    if name_filter:
        search = f"%{name_filter}%"
        query = query.filter(
            models.User.first_name.ilike(search) |
            models.User.last_name.ilike(search) |
            models.User.user_name.ilike(search) |
            models.User.email.ilike(search)
        )
    return query.offset(skip).limit(limit).all()

def get_all_users_for_filtering(db: Session):
    # Return all users, including the admin, for filtering purposes
    return db.query(models.User).all()



def create_user(db: Session, user: schemas.UserCreate, token: Optional[str] = None, role: str = "user"):
    # If a token is provided, validate it (for public registration)
    if token:
        invitation = get_invitation_by_token(db, token)
        if not invitation or invitation.is_used or invitation.expires_at.replace(tzinfo=timezone.utc) < datetime.now(timezone.utc):
            return None # Invalid token
        db.delete(invitation)

    hashed_password = auth.get_password_hash(user.password)
    db_user = models.User(
        **user.model_dump(exclude={"password"}),
        hashed_password=hashed_password,
        role=role # Assign role
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def update_user(db: Session, user_id: int, user_update: schemas.UserUpdate):
    db_user = get_user(db, user_id)
    if not db_user: return None
    update_data = user_update.model_dump(exclude_unset=True)
    if "password" in update_data and update_data["password"]:
        hashed_password = auth.get_password_hash(update_data["password"])
        db_user.hashed_password = hashed_password
    update_data.pop("password", None)
    for key, value in update_data.items():
        setattr(db_user, key, value)
    db.commit()
    db.refresh(db_user)
    return db_user

def delete_user(db: Session, user_id: int):
    db_user = get_user(db, user_id)
    if db_user:
        db.delete(db_user)
        db.commit()
    return db_user

def get_passport(db: Session, passport_id: int):
    return db.query(models.Passport).filter(models.Passport.id == passport_id).first()

def get_passports(db: Session, skip: int = 0, limit: int = 100, user_filter: Optional[str] = None, voyage_filter: Optional[str] = None):
    query = db.query(models.Passport)
    if user_filter:
        if user_filter.isdigit():
            query = query.filter(models.Passport.owner_id == int(user_filter))
        else:
            query = query.join(models.User).filter(
                models.User.first_name.ilike(f"%{user_filter}%") |
                models.User.last_name.ilike(f"%{user_filter}%") |
                models.User.user_name.ilike(f"%{user_filter}%")
            )
    if voyage_filter:
        query = query.join(models.Passport.voyages)
        if voyage_filter.isdigit():
            query = query.filter(models.Voyage.id == int(voyage_filter))
        else:
            query = query.filter(models.Voyage.destination.ilike(f"%{voyage_filter}%"))
    return query.offset(skip).limit(limit).all()

def get_passports_by_user(db: Session, user_id: int):
    return db.query(models.Passport).filter(models.Passport.owner_id == user_id).all()

def create_user_passport(db: Session, passport: schemas.PassportCreate, user_id: int):
    # First, check if a passport with this number already exists for the current user.
    db_passport = db.query(models.Passport).filter(
        models.Passport.passport_number == passport.passport_number,
        models.Passport.owner_id == user_id
    ).first()

    # If the passport does not exist, create a new one.
    if not db_passport:
        passport_data = passport.model_dump(exclude={"destination", "confidence_score"})
        db_passport = models.Passport(
            **passport_data, 
            owner_id=user_id, 
            confidence_score=passport.confidence_score
        )
        db.add(db_passport)
        db.commit()
        db.refresh(db_passport)

    # Now, handle the destination/voyage association.
    if passport.destination:
        # Find the voyage for the user and destination.
        db_voyage = db.query(models.Voyage).filter(
            models.Voyage.user_id == user_id,
            models.Voyage.destination == passport.destination
        ).first()

        # If the voyage doesn't exist, create it.
        if not db_voyage:
            db_voyage = models.Voyage(destination=passport.destination, user_id=user_id)
            db.add(db_voyage)
            # We commit here to give the voyage an ID before associating it
            db.commit()
            db.refresh(db_voyage)

        # Check if the passport is already associated with this voyage.
        if db_passport not in db_voyage.passports:
            db_voyage.passports.append(db_passport)
            db.commit()
            db.refresh(db_passport)
    
    return db_passport

def update_passport(db: Session, passport_id: int, passport_update: schemas.PassportCreate):
    db_passport = get_passport(db, passport_id)
    if not db_passport:
        return None

    if passport_update.destination:
        existing_association = db.query(models.Passport).join(models.Passport.voyages).filter(
            models.Passport.owner_id == db_passport.owner_id,
            models.Passport.passport_number == passport_update.passport_number,
            models.Voyage.destination == passport_update.destination,
            models.Passport.id != passport_id
        ).first()
        if existing_association:
            raise HTTPException(
                status_code=HTTPStatus.CONFLICT,
                detail=f"Le passeport numéro '{passport_update.passport_number}' est déjà enregistré pour la destination '{passport_update.destination}'.",
            )

    update_data = passport_update.model_dump(exclude={"destination"})
    for key, value in update_data.items():
        setattr(db_passport, key, value)

    db_passport.voyages.clear()

    if passport_update.destination:
        db_voyage = db.query(models.Voyage).filter(
            models.Voyage.user_id == db_passport.owner_id,
            models.Voyage.destination == passport_update.destination
        ).first()
        if not db_voyage:
            db_voyage = models.Voyage(destination=passport_update.destination, user_id=db_passport.owner_id)
            db.add(db_voyage)
        db_passport.voyages.append(db_voyage)

    db.commit()
    db.refresh(db_passport)
    return db_passport

def delete_passport(db: Session, passport_id: int):
    db_passport = get_passport(db, passport_id)
    if db_passport:
        db.delete(db_passport)
        db.commit()
    return db_passport

def delete_passports_by_ids(db: Session, *, passport_ids: List[int], user_id: int, is_admin: bool):
    """
    Deletes multiple passports from the database based on a list of IDs.
    - If the user is not an admin, it will only delete passports that belong to them.
    """
    query = db.query(models.Passport).filter(models.Passport.id.in_(passport_ids))
    
    # Security check: Non-admins can only delete their own passports.
    if not is_admin:
        # Correctly checks against the 'owner_id' column
        query = query.filter(models.Passport.owner_id == user_id)
        
    num_deleted = query.delete(synchronize_session=False)
    db.commit()
    return num_deleted

def get_voyage(db: Session, voyage_id: int):
    return db.query(models.Voyage).filter(models.Voyage.id == voyage_id).first()

def get_voyages(db: Session, skip: int = 0, limit: int = 100, user_filter: Optional[str] = None):
    query = db.query(models.Voyage)
    if user_filter:
        if user_filter.isdigit():
            query = query.filter(models.Voyage.user_id == int(user_filter))
        else:
            query = query.join(models.User).filter(
                models.User.first_name.ilike(f"%{user_filter}%") |
                models.User.last_name.ilike(f"%{user_filter}%") |
                models.User.user_name.ilike(f"%{user_filter}%")
            )
    return query.offset(skip).limit(limit).all()

def get_voyages_by_user(db: Session, user_id: int):
    return db.query(models.Voyage).filter(models.Voyage.user_id == user_id).all()

def create_user_voyage(db: Session, voyage: schemas.VoyageCreate, user_id: int, passport_ids: list[int]):
    db_voyage = models.Voyage(destination=voyage.destination, user_id=user_id)
    if passport_ids:
        passports = db.query(models.Passport).filter(models.Passport.id.in_(passport_ids)).all()
        db_voyage.passports.extend(passports)
    db.add(db_voyage)
    db.commit()
    db.refresh(db_voyage)
    return db_voyage

def update_voyage(db: Session, voyage_id: int, voyage_update: schemas.VoyageCreate):
    db_voyage = get_voyage(db, voyage_id)
    if not db_voyage: return None
    db_voyage.destination = voyage_update.destination
    if voyage_update.passport_ids is not None:
        passports = db.query(models.Passport).filter(models.Passport.id.in_(voyage_update.passport_ids)).all()
        db_voyage.passports = passports
    db.commit()
    db.refresh(db_voyage)
    return db_voyage

def delete_voyage(db: Session, voyage_id: int):
    db_voyage = get_voyage(db, voyage_id)
    if db_voyage:
        db.delete(db_voyage)
        db.commit()
    return db_voyage

def filter_data(db: Session, destination: Optional[str], user_id: Optional[int], first_name: Optional[str], last_name: Optional[str]):
    query = db.query(models.Passport)

    if user_id is not None:
        query = query.filter(models.Passport.owner_id == user_id)

    if destination:
        query = query.join(models.Passport.voyages).filter(models.Voyage.destination.ilike(f"%{destination}%"))

    if first_name:
        query = query.filter(models.Passport.first_name.ilike(f"%{first_name}%"))
    if last_name:
        query = query.filter(models.Passport.last_name.ilike(f"%{last_name}%"))

    query = query.options(joinedload(models.Passport.voyages))
    
    results = query.all()
    
    data_list = []
    processed_passport_ids = set()

    for passport in results:
        if passport.id in processed_passport_ids:
            continue
        
        destinations = [v.destination for v in passport.voyages]
        if destination:
            dest_str = destination
        elif destinations:
            dest_str = ", ".join(sorted(list(set(destinations))))
        else:
            dest_str = "N/A"

        data_list.append({
            "id": passport.id, "first_name": passport.first_name, "last_name": passport.last_name,
            "birth_date": passport.birth_date, "delivery_date": passport.delivery_date,
            "expiration_date": passport.expiration_date, "nationality": passport.nationality,
            "passport_number": passport.passport_number, "owner_id": passport.owner_id,
            "destination": dest_str
        })
        processed_passport_ids.add(passport.id)
        
    return data_list

def create_invitation(db: Session, email: str):
    token = secrets.token_urlsafe(32)
    expires_at = datetime.now(timezone.utc) + timedelta(hours=24)
    db_invitation = models.Invitation(email=email, token=token, expires_at=expires_at)
    db.add(db_invitation)
    db.commit()
    db.refresh(db_invitation)
    return db_invitation




def get_invitation_by_token(db: Session, token: str):
    return db.query(models.Invitation).filter(models.Invitation.token == token).first()

def get_invitation_by_email(db: Session, email: str):
    return db.query(models.Invitation).filter(models.Invitation.email == email).first()

def get_invitation(db: Session, invitation_id: int):
    return db.query(models.Invitation).filter(models.Invitation.id == invitation_id).first()

def get_invitations(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.Invitation).offset(skip).limit(limit).all()

def update_invitation(db: Session, invitation_id: int, invitation_update: schemas.InvitationUpdate):
    db_invitation = get_invitation(db, invitation_id)
    if not db_invitation:
        return None
    update_data = invitation_update.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_invitation, key, value)
    db.commit()
    db.refresh(db_invitation)
    return db_invitation

def delete_invitation(db: Session, invitation_id: int):
    db_invitation = get_invitation(db, invitation_id)
    if db_invitation:
        db.delete(db_invitation)
        db.commit()
    return db_invitation

def get_destinations_by_user_id(db: Session, user_id: int) -> List[str]:
    query = db.query(models.Voyage.destination).filter(models.Voyage.user_id == user_id).distinct()
    destinations = [item[0] for item in query.all()]
    return destinations


# --------------- END OF FILE: backend/crud.py ---------------

# --------------- START OF FILE: backend/schemas.py ---------------

# backend/schemas.py

from pydantic import BaseModel, EmailStr
from typing import List, Optional, Any
from datetime import date, datetime

# --- NEW: Schemas for Asynchronous Task Handling ---

class AsyncTaskCreateResponse(BaseModel):
    """Response for a single task creation."""
    task_id: str
    filename: str

class MultiAsyncTaskResponse(BaseModel):
    """Response when multiple background tasks are created."""
    tasks: List[AsyncTaskCreateResponse]

class AsyncTaskStatus(BaseModel):
    """Response when checking the status of a background task."""
    task_id: str
    status: str # e.g., PENDING, PROGRESS, SUCCESS, FAILURE, CANCELLED
    progress: Optional[dict] = None # e.g., {"status": "Uploading..."}
    result: Optional[Any] = None # Will contain the final result on SUCCESS/FAILURE


# --- EXISTING SCHEMAS ---

class VoyageBase(BaseModel):
    destination: str

class VoyageCreate(VoyageBase):
    passport_ids: List[int] = []

class Voyage(VoyageBase):
    id: int
    user_id: int
    class Config:
        from_attributes = True

class PassportBase(BaseModel):
    first_name: str
    last_name: str
    birth_date: date
    expiration_date: Optional[date] = None
    delivery_date: Optional[date] = None
    nationality: str
    passport_number: str
    confidence_score: Optional[float] = None

class PassportCreate(PassportBase):
    destination: Optional[str] = None

class Passport(PassportBase):
    id: int
    owner_id: int
    voyages: List[Voyage] = []
    class Config:
        from_attributes = True

class UserBase(BaseModel):
    first_name: str
    last_name: str
    email: EmailStr
    phone_number: str
    user_name: str

class UserCreate(UserBase):
    password: str

class UserUpdate(BaseModel):
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    email: Optional[EmailStr] = None
    phone_number: Optional[str] = None
    password: Optional[str] = None

class User(UserBase):
    id: int
    role: str
    passports: List["Passport"] = []
    voyages: List[Voyage] = []
    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

class InvitationCreate(BaseModel):
    email: EmailStr

class Invitation(InvitationCreate):
    id: int
    token: str
    expires_at: datetime
    is_used: bool
    class Config:
        from_attributes = True

class InvitationUpdate(BaseModel):
    expires_at: Optional[datetime] = None
    is_used: Optional[bool] = None

class IdsList(BaseModel):
    ids: List[int]

User.model_rebuild()

# --------------- END OF FILE: backend/schemas.py ---------------

# --------------- START OF FILE: backend/models.py ---------------



# /models.py
from sqlalchemy import Boolean, Column, Integer, Float, String, Date, ForeignKey, Table, DateTime
from sqlalchemy.orm import relationship
from database import Base

voyage_passport_association = Table('voyage_passport_association', Base.metadata,
    Column('voyage_id', Integer, ForeignKey('voyages.id'), primary_key=True),
    Column('passport_id', Integer, ForeignKey('passports.id'), primary_key=True)
)

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    first_name = Column(String, index=True)
    last_name = Column(String, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    phone_number = Column(String)
    user_name = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    role = Column(String, default="user")
    passports = relationship("Passport", back_populates="owner", cascade="all, delete-orphan")
    voyages = relationship("Voyage", back_populates="user", cascade="all, delete-orphan")

class Passport(Base):
    __tablename__ = "passports"
    id = Column(Integer, primary_key=True, index=True)
    first_name = Column(String, index=True)
    last_name = Column(String, index=True)
    birth_date = Column(Date)
    delivery_date = Column(Date)
    expiration_date = Column(Date)
    nationality = Column(String, index=True)
    passport_number = Column(String, index=True, nullable=False) # Removed unique=True
    confidence_score = Column(Float)
    owner_id = Column(Integer, ForeignKey("users.id"))
    owner = relationship("User", back_populates="passports")
    voyages = relationship("Voyage", secondary=voyage_passport_association, back_populates="passports")


class Voyage(Base):
    __tablename__ = "voyages"
    id = Column(Integer, primary_key=True, index=True)
    destination = Column(String, index=True, nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"))
    user = relationship("User", back_populates="voyages")
    passports = relationship("Passport", secondary=voyage_passport_association, back_populates="voyages")

class Invitation(Base):
    __tablename__ = "invitations"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    token = Column(String, unique=True, index=True, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    is_used = Column(Boolean, default=False)


# --------------- END OF FILE: backend/models.py ---------------

# --------------- START OF FILE: backend/database.py ---------------

# /database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# SQLALCHEMY_DATABASE_URL = "sqlite:///./data/travel_app.db" # for deployment

SQLALCHEMY_DATABASE_URL = "sqlite:///./travel_app.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# --------------- END OF FILE: backend/database.py ---------------

# --------------- START OF FILE: backend/auth.py ---------------


# /auth.py
from datetime import datetime, timedelta, timezone
from typing import Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlalchemy.orm import Session
import crud, models, schemas
from database import get_db
import os
from dotenv import load_dotenv # You'll need to install this library

# Load environment variables from a .env file (for local development)
load_dotenv()

SECRET_KEY = os.getenv("SECRET_KEY", "a_default_fallback_key_if_not_set")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto", bcrypt__ident="2b")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def authenticate_user(db: Session, username: str, password: str):
    user = crud.get_user_by_username(db, username=username)
    if not user or not verify_password(password, user.hashed_password):
        return False
    return user

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Impossible de valider les informations d'identification",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None: raise credentials_exception
        token_data = schemas.TokenData(username=username)
    except JWTError:
        raise credentials_exception
    user = crud.get_user_by_username(db, username=token_data.username)
    if user is None: raise credentials_exception
    return user

def get_current_active_user(current_user: models.User = Depends(get_current_user)):
    return current_user

def require_admin(current_user: models.User = Depends(get_current_active_user)):
    if current_user.role != "admin":
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Privilèges d'administrateur requis.")
    return current_user


# --------------- END OF FILE: backend/auth.py ---------------

# --------------- START OF FILE: backend/prestart.sh ---------------

#!/bin/bash

# Run the database initialization script
python /app/initial_db.py

# Now, start the Gunicorn server
exec gunicorn -w 4 -k uvicorn.workers.UvicornWorker main:app --bind 0.0.0.0:8000

# --------------- END OF FILE: backend/prestart.sh ---------------

# --------------- START OF FILE: backend/initial_db.py ---------------

import logging
from database import engine, SessionLocal
import models
import crud
import schemas
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def init_db():
    logger.info("Creating initial database tables...")
    # The checkfirst=True is still a good safety measure
    models.Base.metadata.create_all(bind=engine, checkfirst=True)
    logger.info("Database tables created.")

    db = SessionLocal()
    # Check if admin user exists and create one if not
    admin_user = crud.get_user_by_username(db, username="admin")
    if not admin_user:
        logger.info("Admin user not found, creating one...")
        ADMIN_PASSWORD = os.getenv("ADMIN_PASSWORD")
        if not ADMIN_PASSWORD:
            logger.warning("ADMIN_PASSWORD environment variable not set. Admin user not created.")
        else:
            admin = schemas.UserCreate(
                first_name="Admin",
                last_name="User",
                email="admin@example.com",
                phone_number="1234567890",
                user_name="admin",
                password=ADMIN_PASSWORD
            )
            crud.create_user(db=db, user=admin, role="admin", token=None)
            logger.info("Admin user created.")
    else:
        logger.info("Admin user already exists.")
    db.close()

if __name__ == "__main__":
    init_db()

# --------------- END OF FILE: backend/initial_db.py ---------------

# --------------- START OF FILE: backend/ocr_service.py ---------------

# # backend/ocr_service.py

# import re
# import os
# import json
# from datetime import datetime
# from google.cloud import vision, storage
# from google.api_core import exceptions
# from fastapi import HTTPException
# import logging
# from typing import Tuple, Optional, Dict

# # Use a specific logger for this module
# logger = logging.getLogger("ocr_service")
# logger.setLevel(logging.INFO)

# # --- Google Cloud Clients ---
# vision_client = None
# storage_client = None
# GCS_BUCKET_NAME = os.getenv("GCS_BUCKET_NAME")

# try:
#     logger.info("--- [GCP] Initializing Google Cloud clients... ---")
#     if not os.getenv("GOOGLE_APPLICATION_CREDENTIALS"):
#         logger.error("🔴 [GCP] CRITICAL: GOOGLE_APPLICATION_CREDENTIALS environment variable is NOT SET.")
#         raise ValueError("GOOGLE_APPLICATION_CREDENTIALS environment variable must be set.")
    
#     vision_client = vision.ImageAnnotatorClient()
#     storage_client = storage.Client()
#     logger.info("✅ [GCP] Google Cloud clients initialized successfully.")
    
#     if not GCS_BUCKET_NAME:
#         logger.warning("🟡 [GCP] WARNING: GCS_BUCKET_NAME environment variable is not set.")
#     else:
#         logger.info(f"✅ [GCP] Using GCS Bucket: {GCS_BUCKET_NAME}")

# except Exception as e:
#     logger.error(f"🔴 [GCP] FAILED to initialize Google Cloud clients: {e}")
#     # The application can still run, but OCR features will fail.

# def _upload_to_gcs(file_path: str, destination_blob_name: str) -> str:
#     """Uploads a file to the GCS bucket."""
#     logger.info(f"--- [GCS] Attempting to upload '{os.path.basename(file_path)}' to gs://{GCS_BUCKET_NAME}/{destination_blob_name} ---")
#     if not GCS_BUCKET_NAME or not storage_client:
#         logger.error("🔴 [GCS] Upload failed: GCS_BUCKET_NAME is not set or storage client is not initialized.")
#         raise ValueError("GCS bucket or storage client not configured.")
    
#     try:
#         bucket = storage_client.bucket(GCS_BUCKET_NAME)
#         blob = bucket.blob(destination_blob_name)
#         blob.upload_from_filename(file_path)
#         gcs_uri = f"gs://{GCS_BUCKET_NAME}/{destination_blob_name}"
#         logger.info(f"✅ [GCS] Successfully uploaded file. URI: {gcs_uri}")
#         return gcs_uri
#     except exceptions.NotFound:
#         logger.error(f"🔴 [GCS] Upload failed: Bucket '{GCS_BUCKET_NAME}' not found.")
#         raise
#     except Exception as e:
#         logger.error(f"🔴 [GCS] An unexpected error occurred during upload: {e}")
#         raise

# def _delete_from_gcs(gcs_uri: str):
#     """Deletes a file from the GCS bucket."""
#     logger.info(f"--- [GCS] Attempting to delete blob: {gcs_uri} ---")
#     if not GCS_BUCKET_NAME or not storage_client:
#         logger.error("🔴 [GCS] Delete failed: GCS not configured.")
#         return
#     if not gcs_uri.startswith(f"gs://{GCS_BUCKET_NAME}/"):
#         logger.error(f"🔴 [GCS] Cannot delete blob: URI '{gcs_uri}' is not in the configured bucket.")
#         return
        
#     try:
#         blob_name = gcs_uri.replace(f"gs://{GCS_BUCKET_NAME}/", "")
#         bucket = storage_client.bucket(GCS_BUCKET_NAME)
#         blob = bucket.blob(blob_name)
#         blob.delete()
#         logger.info(f"✅ [GCS] Successfully deleted blob: {gcs_uri}")
#     except Exception as e:
#         logger.error(f"🔴 [GCS] Failed to delete blob {gcs_uri}: {e}")

# def start_async_ocr_extraction(file_path: str, content_type: str) -> Tuple[str, str]:
#     logger.info(f"--- [Vision] Starting async OCR extraction for '{os.path.basename(file_path)}' ---")
#     if not vision_client:
#         logger.error("🔴 [Vision] Cannot start OCR: Google Vision client is not initialized.")
#         raise RuntimeError("Google Vision client is not initialized.")
        
#     if not content_type == "application/pdf":
#         raise HTTPException(status_code=400, detail="Only multi-page PDF files are supported for batch processing.")

#     timestamp = datetime.utcnow().strftime('%Y%m%d%H%M%S')
#     unique_filename = f"uploads/{timestamp}-{os.path.basename(file_path)}"

#     # 1. Upload to GCS
#     gcs_source_uri = _upload_to_gcs(file_path, unique_filename)

#     # 2. Configure and start OCR request
#     gcs_destination_uri = f"gs://{GCS_BUCKET_NAME}/results/{unique_filename}-"
#     logger.info(f"[Vision] Setting OCR output destination to: {gcs_destination_uri}")
    
#     mime_type = 'application/pdf'
#     feature = vision.Feature(type_=vision.Feature.Type.DOCUMENT_TEXT_DETECTION)
#     gcs_source = vision.GcsSource(uri=gcs_source_uri)
#     input_config = vision.InputConfig(gcs_source=gcs_source, mime_type=mime_type)
#     gcs_destination = vision.GcsDestination(uri=gcs_destination_uri)
#     output_config = vision.OutputConfig(gcs_destination=gcs_destination, batch_size=5)

#     async_request = vision.AsyncAnnotateFileRequest(
#         features=[feature],
#         input_config=input_config,
#         output_config=output_config
#     )

#     logger.info("[Vision] Sending async_batch_annotate_files request to Google...")
#     operation = vision_client.async_batch_annotate_files(requests=[async_request])
#     logger.info(f"✅ [Vision] Started Google Vision async operation. Name: {operation.operation.name}")
#     return operation.operation.name, gcs_source_uri

# def get_async_ocr_results(operation_name: str) -> dict:
#     if not vision_client or not storage_client:
#         raise RuntimeError("Google Cloud clients are not initialized.")
        
#     logger.info(f"--- [Vision] Checking operation status for: {operation_name} ---")
#     operation_client = vision_client.transport.operations_client
#     operation = operation_client.get_operation(name=operation_name)

#     if not operation.done:
#         logger.info("[Vision] Operation is still processing...")
#         return {"status": "PROCESSING"}

#     if operation.error.message:
#         logger.error(f"🔴 [Vision] Operation failed: {operation.error.message}")
#         return {"status": "FAILURE", "error": operation.error.message}

#     logger.info("✅ [Vision] Operation complete. Processing results from GCS...")
#     from google.cloud.vision_v1.types import AsyncBatchAnnotateFilesResponse
#     response_any = operation.response
#     response = AsyncBatchAnnotateFilesResponse()
#     response_any.Unpack(response)
    
#     destination_uri = response.output_config.gcs_destination.uri
#     prefix = destination_uri.replace(f"gs://{GCS_BUCKET_NAME}/", "")
    
#     logger.info(f"[GCS] Listing result blobs with prefix: '{prefix}'")
#     bucket = storage_client.bucket(GCS_BUCKET_NAME)
#     blob_list = list(bucket.list_blobs(prefix=prefix))
#     logger.info(f"[GCS] Found {len(blob_list)} result blob(s).")

#     results = []
#     for blob in blob_list:
#         logger.info(f"[GCS] Downloading and parsing result blob: {blob.name}")
#         json_string = blob.download_as_string()
#         response_json = json.loads(json_string)
        
#         for page_response in response_json.get('responses', []):
#             page_context = page_response.get('context', {})
#             actual_page_num = page_context.get('page_number', 'N/A')
#             try:
#                 if page_response.get('error'):
#                     raise ValueError(page_response['error']['message'])
                
#                 full_text = page_response.get('fullTextAnnotation', {}).get('text', '')
#                 if not full_text:
#                     raise ValueError("No text detected on page.")

#                 parsed_data = _parse_french_id_card_text(full_text)
                
#                 total_confidence, symbol_count = 0, 0
#                 for page in page_response.get('fullTextAnnotation', {}).get('pages', []):
#                     for block in page.get('blocks', []):
#                         for paragraph in block.get('paragraphs', []):
#                             for word in paragraph.get('words', []):
#                                 for symbol in word.get('symbols', []):
#                                     total_confidence += symbol.get('confidence', 0)
#                                     symbol_count += 1
                
#                 average_confidence = (total_confidence / symbol_count) if symbol_count > 0 else 0.0
#                 parsed_data['confidence_score'] = round(average_confidence, 4)
#                 logger.info(f"✅ Parsed page {actual_page_num} successfully. Confidence: {average_confidence:.2%}")
#                 results.append({"page_number": actual_page_num, "data": parsed_data, "status": "SUCCESS"})
#             except Exception as e:
#                 logger.warning(f"🟡 Failed to parse page {actual_page_num}: {e}")
#                 results.append({"page_number": actual_page_num, "error": str(e), "status": "FAILURE"})
    
#     logger.info(f"--- [GCS] Cleaning up {len(blob_list)} result blobs... ---")
#     for blob in blob_list:
#         blob.delete()
        
#     return {"status": "SUCCESS", "results": results}

# def cancel_google_ocr_operation(operation_name: str):
#     try:
#         if not vision_client:
#             logger.error("🔴 [Vision] Vision client not initialized, cannot cancel operation.")
#             return
#         logger.info(f"--- [Vision] Requesting cancellation for operation: {operation_name} ---")
#         vision_client.transport.operations_client.cancel_operation(name=operation_name)
#         logger.info(f"✅ [Vision] Cancellation request sent for {operation_name}.")
#     except Exception as e:
#         logger.error(f"🔴 [Vision] Failed to send cancellation request for {operation_name}: {e}")

# # ... (keep the _parse_date and _parse_french_id_card_text functions as they are) ...
# def _parse_date(date_str: Optional[str]) -> Optional[str]:
#     """Helper to parse and format date string."""
#     if not date_str:
#         return None
#     try:
#         # Assuming format DD.MM.YYYY or DD/MM/YYYY
#         cleaned_date_str = date_str.replace('.', '/')
#         dt_obj = datetime.strptime(cleaned_date_str, '%d/%m/%Y')
#         return dt_obj.strftime('%Y-%m-%d')
#     except ValueError:
#         logger.warning(f"Could not parse date string: {date_str}")
#         return None

# def _parse_french_id_card_text(raw_text: str) -> Dict[str, Optional[str]]:
#     """
#     Parses raw OCR text from a French ID card to extract structured data.
#     This parser is an educated guess and may need significant refinement
#     based on the quality and format of your specific document scans.
#     """
#     data = {
#         "first_name": None, "last_name": None, "passport_number": None,
#         "birth_date": None, "delivery_date": None, "expiration_date": None,
#         "nationality": "FRANCAISE",
#     }
#     text_lines = [line.strip() for line in raw_text.split('\n')]
#     full_text_single_line = ' '.join(text_lines)
#     id_match = re.search(r'(\b\d{2}[A-Z\d]{2}\s?\d{5}\b)', full_text_single_line)
#     if id_match:
#         data["passport_number"] = id_match.group(1).replace(" ", "")
#     last_name_match = re.search(r'Nom\s*[:\s]+\s*([A-Z\s\'-]+)', raw_text, re.IGNORECASE)
#     if last_name_match:
#         data["last_name"] = last_name_match.group(1).strip()
#     first_name_match = re.search(r'Prénom\(s\)\s*[:\s]+\s*([A-Z\s\'-]+)', raw_text, re.IGNORECASE)
#     if first_name_match:
#         data["first_name"] = first_name_match.group(1).strip()
#     birth_date_match = re.search(r'Né\(e\)\s+le\s+(\d{2}[./]\d{2}[./]\d{4})', raw_text, re.IGNORECASE)
#     if birth_date_match:
#         data["birth_date"] = _parse_date(birth_date_match.group(1))
#     date_pattern = r'(\d{2}\.\d{2}\.\d{4})'
#     all_dates = re.findall(date_pattern, full_text_single_line)
#     if len(all_dates) >= 2:
#         data["delivery_date"] = _parse_date(all_dates[0])
#         data["expiration_date"] = _parse_date(all_dates[1])
#     mrz_line = None
#     for line in text_lines:
#         if line.startswith('IDFRA'):
#             mrz_line = line.replace(' ', '')
#             break
#     if mrz_line:
#         parts = mrz_line[5:].split('<<')
#         if len(parts) >= 2:
#             if not data["last_name"]:
#                 data["last_name"] = parts[0].replace('<', ' ').strip()
#             if not data["first_name"]:
#                 data["first_name"] = parts[1].replace('<', ' ').strip()
#     if not all([data["last_name"], data["first_name"], data["birth_date"], data["passport_number"]]):
#         missing_fields = [k for k, v in data.items() if v is None and k in ["last_name", "first_name", "birth_date", "passport_number"]]
#         raise ValueError(f"Could not parse all required fields. Missing: {', '.join(missing_fields)}.")
#     return data



















# backend/ocr_service.py - FIXED PROTOBUF ISSUE

import re
import os
import json
from datetime import datetime
from google.cloud import vision, storage
from google.api_core import exceptions
from fastapi import HTTPException
import logging
from typing import Tuple, Optional, Dict

# Use a specific logger for this module
logger = logging.getLogger("ocr_service")
logger.setLevel(logging.INFO)

# --- Google Cloud Clients ---
vision_client = None
storage_client = None
GCS_BUCKET_NAME = os.getenv("GCS_BUCKET_NAME")

try:
    logger.info("--- [GCP] Initializing Google Cloud clients... ---")
    if not os.getenv("GOOGLE_APPLICATION_CREDENTIALS"):
        logger.error("🔴 [GCP] CRITICAL: GOOGLE_APPLICATION_CREDENTIALS environment variable is NOT SET.")
        raise ValueError("GOOGLE_APPLICATION_CREDENTIALS environment variable must be set.")
    
    vision_client = vision.ImageAnnotatorClient()
    storage_client = storage.Client()
    logger.info("✅ [GCP] Google Cloud clients initialized successfully.")
    
    if not GCS_BUCKET_NAME:
        logger.warning("🟡 [GCP] WARNING: GCS_BUCKET_NAME environment variable is not set.")
    else:
        logger.info(f"✅ [GCP] Using GCS Bucket: {GCS_BUCKET_NAME}")

except Exception as e:
    logger.error(f"🔴 [GCP] FAILED to initialize Google Cloud clients: {e}")
    # The application can still run, but OCR features will fail.

def _upload_to_gcs(file_path: str, destination_blob_name: str) -> str:
    """Uploads a file to the GCS bucket."""
    logger.info(f"--- [GCS] Attempting to upload '{os.path.basename(file_path)}' to gs://{GCS_BUCKET_NAME}/{destination_blob_name} ---")
    if not GCS_BUCKET_NAME or not storage_client:
        logger.error("🔴 [GCS] Upload failed: GCS_BUCKET_NAME is not set or storage client is not initialized.")
        raise ValueError("GCS bucket or storage client not configured.")
    
    try:
        bucket = storage_client.bucket(GCS_BUCKET_NAME)
        blob = bucket.blob(destination_blob_name)
        blob.upload_from_filename(file_path)
        gcs_uri = f"gs://{GCS_BUCKET_NAME}/{destination_blob_name}"
        logger.info(f"✅ [GCS] Successfully uploaded file. URI: {gcs_uri}")
        return gcs_uri
    except exceptions.NotFound:
        logger.error(f"🔴 [GCS] Upload failed: Bucket '{GCS_BUCKET_NAME}' not found.")
        raise
    except Exception as e:
        logger.error(f"🔴 [GCS] An unexpected error occurred during upload: {e}")
        raise

def _delete_from_gcs(gcs_uri: str):
    """Deletes a file from the GCS bucket."""
    logger.info(f"--- [GCS] Attempting to delete blob: {gcs_uri} ---")
    if not GCS_BUCKET_NAME or not storage_client:
        logger.error("🔴 [GCS] Delete failed: GCS not configured.")
        return
    if not gcs_uri.startswith(f"gs://{GCS_BUCKET_NAME}/"):
        logger.error(f"🔴 [GCS] Cannot delete blob: URI '{gcs_uri}' is not in the configured bucket.")
        return
        
    try:
        blob_name = gcs_uri.replace(f"gs://{GCS_BUCKET_NAME}/", "")
        bucket = storage_client.bucket(GCS_BUCKET_NAME)
        blob = bucket.blob(blob_name)
        blob.delete()
        logger.info(f"✅ [GCS] Successfully deleted blob: {gcs_uri}")
    except Exception as e:
        logger.error(f"🔴 [GCS] Failed to delete blob {gcs_uri}: {e}")

def start_async_ocr_extraction(file_path: str, content_type: str) -> Tuple[str, str]:
    logger.info(f"--- [Vision] Starting async OCR extraction for '{os.path.basename(file_path)}' ---")
    if not vision_client:
        logger.error("🔴 [Vision] Cannot start OCR: Google Vision client is not initialized.")
        raise RuntimeError("Google Vision client is not initialized.")
        
    if not content_type == "application/pdf":
        raise HTTPException(status_code=400, detail="Only multi-page PDF files are supported for batch processing.")

    timestamp = datetime.utcnow().strftime('%Y%m%d%H%M%S')
    unique_filename = f"uploads/{timestamp}-{os.path.basename(file_path)}"

    # 1. Upload to GCS
    gcs_source_uri = _upload_to_gcs(file_path, unique_filename)

    # 2. Configure and start OCR request
    gcs_destination_uri = f"gs://{GCS_BUCKET_NAME}/results/{unique_filename}-"
    logger.info(f"[Vision] Setting OCR output destination to: {gcs_destination_uri}")
    
    mime_type = 'application/pdf'
    feature = vision.Feature(type_=vision.Feature.Type.DOCUMENT_TEXT_DETECTION)
    gcs_source = vision.GcsSource(uri=gcs_source_uri)
    input_config = vision.InputConfig(gcs_source=gcs_source, mime_type=mime_type)
    gcs_destination = vision.GcsDestination(uri=gcs_destination_uri)
    output_config = vision.OutputConfig(gcs_destination=gcs_destination, batch_size=5)

    async_request = vision.AsyncAnnotateFileRequest(
        features=[feature],
        input_config=input_config,
        output_config=output_config
    )

    logger.info("[Vision] Sending async_batch_annotate_files request to Google...")
    operation = vision_client.async_batch_annotate_files(requests=[async_request])
    logger.info(f"✅ [Vision] Started Google Vision async operation. Name: {operation.operation.name}")
    return operation.operation.name, gcs_source_uri

def get_async_ocr_results(operation_name: str) -> dict:
    if not vision_client or not storage_client:
        raise RuntimeError("Google Cloud clients are not initialized.")
        
    logger.info(f"--- [Vision] Checking operation status for: {operation_name} ---")
    operation_client = vision_client.transport.operations_client
    operation = operation_client.get_operation(name=operation_name)

    if not operation.done:
        logger.info("[Vision] Operation is still processing...")
        return {"status": "PROCESSING"}

    if operation.error.message:
        logger.error(f"🔴 [Vision] Operation failed: {operation.error.message}")
        return {"status": "FAILURE", "error": operation.error.message}

    logger.info("✅ [Vision] Operation complete. Processing results from GCS...")
    
    # FIX: Don't use Unpack() with proto-plus objects
    # Instead, directly access the response data
    # The operation.response is already the correct type
    response = operation.metadata
    
    # Get the output configuration from the original operation metadata
    # The actual results are stored in GCS, so we need to read them from there
    
    # Extract GCS destination from operation metadata
    # Since we know the destination pattern, we can construct it
    gcs_destination_uri = None
    
    # Try to get destination from operation metadata
    try:
        # The response object should have output_config
        if hasattr(operation, 'metadata'):
            metadata = operation.metadata
            if hasattr(metadata, 'output_config'):
                gcs_destination_uri = metadata.output_config.gcs_destination.uri
    except Exception as e:
        logger.warning(f"Could not extract destination from metadata: {e}")
    
    # Fallback: construct destination from operation name
    if not gcs_destination_uri:
        # Extract timestamp and filename from operation name pattern
        # Operation name format: projects/PROJECT/operations/OPERATION_ID
        # We stored files as: uploads/TIMESTAMP-FILENAME
        # Results are at: results/uploads/TIMESTAMP-FILENAME-
        logger.info("Using fallback method to determine GCS destination")
        
        # We need to list blobs in the results directory
        # Since we don't have the exact prefix, we'll search for recent results
        bucket = storage_client.bucket(GCS_BUCKET_NAME)
        prefix = "results/uploads/"
        
        # List all result blobs and find the most recent ones
        blobs = list(bucket.list_blobs(prefix=prefix))
        
        if not blobs:
            logger.error("No result blobs found in GCS")
            return {"status": "FAILURE", "error": "No OCR results found in storage"}
        
        # Sort by creation time and get the most recent
        blobs.sort(key=lambda x: x.time_created, reverse=True)
        
        # Get the prefix of the most recent blob (without the output-X-to-Y.json part)
        most_recent_blob = blobs[0]
        blob_name = most_recent_blob.name
        # Extract prefix (everything before output-X-to-Y.json)
        import re
        match = re.match(r'(results/uploads/\d+-[^/]+)-', blob_name)
        if match:
            prefix = match.group(1) + '-'
        else:
            prefix = blob_name.rsplit('output-', 1)[0]
    else:
        prefix = gcs_destination_uri.replace(f"gs://{GCS_BUCKET_NAME}/", "")
    
    logger.info(f"[GCS] Listing result blobs with prefix: '{prefix}'")
    bucket = storage_client.bucket(GCS_BUCKET_NAME)
    blob_list = list(bucket.list_blobs(prefix=prefix))
    logger.info(f"[GCS] Found {len(blob_list)} result blob(s).")

    results = []
    for blob in blob_list:
        logger.info(f"[GCS] Downloading and parsing result blob: {blob.name}")
        json_string = blob.download_as_string()
        response_json = json.loads(json_string)
        
        for page_response in response_json.get('responses', []):
            page_context = page_response.get('context', {})
            actual_page_num = page_context.get('page_number', 'N/A')
            try:
                if page_response.get('error'):
                    raise ValueError(page_response['error']['message'])
                
                full_text = page_response.get('fullTextAnnotation', {}).get('text', '')
                if not full_text:
                    raise ValueError("No text detected on page.")

                parsed_data = _parse_french_id_card_text(full_text)
                
                total_confidence, symbol_count = 0, 0
                for page in page_response.get('fullTextAnnotation', {}).get('pages', []):
                    for block in page.get('blocks', []):
                        for paragraph in block.get('paragraphs', []):
                            for word in paragraph.get('words', []):
                                for symbol in word.get('symbols', []):
                                    total_confidence += symbol.get('confidence', 0)
                                    symbol_count += 1
                
                average_confidence = (total_confidence / symbol_count) if symbol_count > 0 else 0.0
                parsed_data['confidence_score'] = round(average_confidence, 4)
                logger.info(f"✅ Parsed page {actual_page_num} successfully. Confidence: {average_confidence:.2%}")
                results.append({"page_number": actual_page_num, "data": parsed_data, "status": "SUCCESS"})
            except Exception as e:
                logger.warning(f"🟡 Failed to parse page {actual_page_num}: {e}")
                results.append({"page_number": actual_page_num, "error": str(e), "status": "FAILURE"})
    
    logger.info(f"--- [GCS] Cleaning up {len(blob_list)} result blobs... ---")
    for blob in blob_list:
        blob.delete()
        
    return {"status": "SUCCESS", "results": results}

def cancel_google_ocr_operation(operation_name: str):
    try:
        if not vision_client:
            logger.error("🔴 [Vision] Vision client not initialized, cannot cancel operation.")
            return
        logger.info(f"--- [Vision] Requesting cancellation for operation: {operation_name} ---")
        vision_client.transport.operations_client.cancel_operation(name=operation_name)
        logger.info(f"✅ [Vision] Cancellation request sent for {operation_name}.")
    except Exception as e:
        logger.error(f"🔴 [Vision] Failed to send cancellation request for {operation_name}: {e}")

def _parse_date(date_str: Optional[str]) -> Optional[str]:
    """Helper to parse and format date string."""
    if not date_str:
        return None
    try:
        # Assuming format DD.MM.YYYY or DD/MM/YYYY
        cleaned_date_str = date_str.replace('.', '/')
        dt_obj = datetime.strptime(cleaned_date_str, '%d/%m/%Y')
        return dt_obj.strftime('%Y-%m-%d')
    except ValueError:
        logger.warning(f"Could not parse date string: {date_str}")
        return None

def _parse_french_id_card_text(raw_text: str) -> Dict[str, Optional[str]]:
    """
    Parses raw OCR text from a French ID card to extract structured data.
    This parser is an educated guess and may need significant refinement
    based on the quality and format of your specific document scans.
    
    FIX: Added better error handling with specific missing field reporting.
    """
    data = {
        "first_name": None, "last_name": None, "passport_number": None,
        "birth_date": None, "delivery_date": None, "expiration_date": None,
        "nationality": "FRANCAISE",
    }
    text_lines = [line.strip() for line in raw_text.split('\n')]
    full_text_single_line = ' '.join(text_lines)
    
    # Extract passport/ID number
    id_match = re.search(r'(\b\d{2}[A-Z\d]{2}\s?\d{5}\b)', full_text_single_line)
    if id_match:
        data["passport_number"] = id_match.group(1).replace(" ", "")
    
    # Extract last name
    last_name_match = re.search(r'Nom\s*[:\s]+\s*([A-Z\s\'-]+)', raw_text, re.IGNORECASE)
    if last_name_match:
        data["last_name"] = last_name_match.group(1).strip()
    
    # Extract first name
    first_name_match = re.search(r'Prénom\(s\)\s*[:\s]+\s*([A-Z\s\'-]+)', raw_text, re.IGNORECASE)
    if first_name_match:
        data["first_name"] = first_name_match.group(1).strip()
    
    # Extract birth date
    birth_date_match = re.search(r'Né\(e\)\s+le\s+(\d{2}[./]\d{2}[./]\d{4})', raw_text, re.IGNORECASE)
    if birth_date_match:
        data["birth_date"] = _parse_date(birth_date_match.group(1))
    
    # Extract delivery and expiration dates
    date_pattern = r'(\d{2}\.\d{2}\.\d{4})'
    all_dates = re.findall(date_pattern, full_text_single_line)
    if len(all_dates) >= 2:
        data["delivery_date"] = _parse_date(all_dates[0])
        data["expiration_date"] = _parse_date(all_dates[1])
    
    # Try to extract from MRZ line
    mrz_line = None
    for line in text_lines:
        if line.startswith('IDFRA'):
            mrz_line = line.replace(' ', '')
            break
    
    if mrz_line:
        parts = mrz_line[5:].split('<<')
        if len(parts) >= 2:
            if not data["last_name"]:
                data["last_name"] = parts[0].replace('<', ' ').strip()
            if not data["first_name"]:
                data["first_name"] = parts[1].replace('<', ' ').strip()
    
    # FIX: Better error reporting - identify which specific fields are missing
    required_fields = ["last_name", "first_name", "birth_date", "passport_number"]
    missing_fields = [field for field in required_fields if not data[field]]
    
    if missing_fields:
        missing_list = ', '.join([field.replace('_', ' ').title() for field in missing_fields])
        logger.warning(f"Missing required fields in parsed document: {missing_list}")
        raise ValueError(
            f"Could not extract required fields from document. Missing: {missing_list}. "
            f"This may be due to poor image quality or unsupported document format."
        )
    
    return data

# --------------- END OF FILE: backend/ocr_service.py ---------------

# --------------- START OF FILE: backend/celery_worker.py ---------------

# # backend/celery_worker.py

# import os
# from dotenv import load_dotenv
# load_dotenv()
# import time
# from typing import Optional
# import tempfile
# import base64
# import ocr_service
# import crud
# import schemas
# from database import SessionLocal
# from celery import Celery, Task
# from celery.signals import task_revoked
# from celery.utils.log import get_task_logger

# # --- Celery Configuration ---
# # CHANGE THIS
# CELERY_BROKER_URL = os.getenv("CELERY_BROKER_URL", "redis://localhost:6379/0")
# CELERY_RESULT_BACKEND = os.getenv("CELERY_RESULT_BACKEND", "redis://localhost:6379/0")

# celery_app = Celery(
#     "tasks",
#     broker=CELERY_BROKER_URL,
#     backend=CELERY_RESULT_BACKEND
# )
# celery_app.conf.update(
#     accept_content=['json'],
#     task_serializer='json',
#     result_serializer='json',
#     task_track_started=True,
# )

# logger = get_task_logger(__name__)


# # --- MODIFICATION START ---
# @task_revoked.connect
# def on_task_revoked(request, terminated, signum, expired, **kwargs):
#     """
#     Handler to log when a task is revoked.
#     Cleanup is now handled entirely within the task's 'finally' block.
#     """
#     # The 'request' object here is a 'Request' class, not the task context.
#     # We can get the task ID directly from it.
#     logger.warning(
#         f"Task {request.id} was revoked. "
#         f"Terminated: {terminated}, Signal: {signum}, Expired: {expired}"
#     )
# # --- MODIFICATION END ---


# @celery_app.task(bind=True, name='tasks.extract_document_data')
# def extract_document_data(self, file_content: bytes, original_filename: str, content_type: str, destination: Optional[str], user_id: int):
#     """
#     Celery task to perform OCR, parse results, and save them to the database.
#     """
#     gcs_source_uri = None
#     google_operation_name = None
#     file_path = None

#     try:
#         # Decode the Base64 string back into bytes
#         file_content = base64.b64decode(file_content)

#         # Create a temporary file inside the worker container to store the content
#         with tempfile.NamedTemporaryFile(delete=False, suffix=f"-{original_filename}") as temp_file:
#             temp_file.write(file_content)
#             file_path = temp_file.name

#         self.update_state(state='PROGRESS', meta={'status': 'Uploading to cloud...'})
#         google_operation_name, gcs_source_uri = ocr_service.start_async_ocr_extraction(file_path, content_type)

#         logger.info(f"Task {self.request.id} started Google operation {google_operation_name}")
#         self.update_state(state='PROGRESS', meta={'status': 'Processing document...'})
        
#         while True:
#             if self.is_revoked():
#                 logger.warning(f"Task {self.request.id} is revoked during processing loop.")
#                 return {'status': 'CANCELLED', 'detail': 'Task was cancelled by user.'}

#             result = ocr_service.get_async_ocr_results(google_operation_name)
            
#             if result['status'] == 'SUCCESS':
#                 logger.info(f"Google operation {google_operation_name} succeeded.")
                
#                 self.update_state(state='PROGRESS', meta={'status': 'Saving results to database...'})
                
#                 db = SessionLocal()
#                 success_count = 0
#                 failures = []
#                 try:
#                     for page_result in result.get('results', []):
#                         if page_result.get('status') == 'SUCCESS':
#                             passport_data = schemas.PassportCreate(
#                                 **page_result['data'],
#                                 destination=destination 
#                             )
#                             crud.create_user_passport(db=db, passport=passport_data, user_id=user_id)
#                             success_count += 1
#                         else:
#                             failures.append({
#                                 "page": page_result.get('page_number', 'N/A'),
#                                 "error": page_result.get('error', 'Unknown parsing error')
#                             })
#                 finally:
#                     db.close()

#                 final_status = {
#                     'status': 'COMPLETE',
#                     'filename': original_filename,
#                     'successful_pages': success_count,
#                     'failed_pages': failures
#                 }
#                 return final_status

#             elif result['status'] == 'FAILURE':
#                 logger.error(f"Google operation {google_operation_name} failed: {result.get('error')}")
#                 raise Exception(f"Google Vision API Error: {result.get('error', 'Unknown error')}")
            
#             time.sleep(10)

#     except Exception as e:
#         logger.error(f"Error in Celery task {self.request.id}: {e}", exc_info=True)
#         raise e
#     finally:
#         logger.info(f"Cleaning up resources for task {self.request.id}.")
#         if self.is_revoked() and google_operation_name:
#              ocr_service.cancel_google_ocr_operation(google_operation_name)
#         if gcs_source_uri:
#             ocr_service._delete_from_gcs(gcs_source_uri)
#         if file_path and os.path.exists(file_path):
#             os.remove(file_path)
#             logger.info(f"Cleaned up temporary file: {file_path}")




# backend/celery_worker.py - CORRECTED VERSION

import os
from dotenv import load_dotenv
load_dotenv()
import time
from typing import Optional
import tempfile
import base64
import ocr_service
import crud
import schemas
from database import SessionLocal
from celery import Celery
from celery.contrib.abortable import AbortableTask
from celery.signals import task_revoked
from celery.utils.log import get_task_logger

# --- Celery Configuration ---
CELERY_BROKER_URL = os.getenv("CELERY_BROKER_URL", "redis://localhost:6379/0")
CELERY_RESULT_BACKEND = os.getenv("CELERY_RESULT_BACKEND", "redis://localhost:6379/0")

celery_app = Celery(
    "tasks",
    broker=CELERY_BROKER_URL,
    backend=CELERY_RESULT_BACKEND
)
celery_app.conf.update(
    accept_content=['json'],
    task_serializer='json',
    result_serializer='json',
    task_track_started=True,
)

logger = get_task_logger(__name__)


@task_revoked.connect
def on_task_revoked(request, terminated, signum, expired, **kwargs):
    """
    Handler to log when a task is revoked.
    Cleanup is handled within the task's 'finally' block.
    """
    logger.warning(
        f"Task {request.id} was revoked. "
        f"Terminated: {terminated}, Signal: {signum}, Expired: {expired}"
    )


# FIX: Use AbortableTask as base class to enable revocation checking
@celery_app.task(bind=True, base=AbortableTask, name='tasks.extract_document_data')
def extract_document_data(self, file_content: bytes, original_filename: str, content_type: str, destination: Optional[str], user_id: int):
    """
    Celery task to perform OCR, parse results, and save them to the database.
    
    Uses AbortableTask to properly support cancellation via is_aborted().
    """
    gcs_source_uri = None
    google_operation_name = None
    file_path = None
    was_cancelled = False

    try:
        # Decode the Base64 string back into bytes
        file_content = base64.b64decode(file_content)

        # Create a temporary file inside the worker container to store the content
        with tempfile.NamedTemporaryFile(delete=False, suffix=f"-{original_filename}") as temp_file:
            temp_file.write(file_content)
            file_path = temp_file.name

        # FIX: Check for early cancellation using is_aborted()
        if self.is_aborted():
            was_cancelled = True
            logger.warning(f"Task {self.request.id} was cancelled before OCR started.")
            return {'status': 'CANCELLED', 'detail': 'Task was cancelled by user.'}

        self.update_state(state='PROGRESS', meta={'status': 'Uploading to cloud...'})
        google_operation_name, gcs_source_uri = ocr_service.start_async_ocr_extraction(file_path, content_type)

        logger.info(f"Task {self.request.id} started Google operation {google_operation_name}")
        self.update_state(state='PROGRESS', meta={'status': 'Processing document...'})
        
        # Add timeout protection to prevent infinite loops
        max_poll_attempts = 120  # 10 minutes with 5-second intervals
        poll_count = 0
        
        while poll_count < max_poll_attempts:
            # FIX: Check cancellation using is_aborted()
            if self.is_aborted():
                was_cancelled = True
                logger.warning(f"Task {self.request.id} was cancelled during processing loop.")
                return {'status': 'CANCELLED', 'detail': 'Task was cancelled by user.'}

            result = ocr_service.get_async_ocr_results(google_operation_name)
            
            if result['status'] == 'SUCCESS':
                logger.info(f"Google operation {google_operation_name} succeeded.")
                
                self.update_state(state='PROGRESS', meta={'status': 'Saving results to database...'})
                
                db = SessionLocal()
                success_count = 0
                failures = []
                try:
                    for page_result in result.get('results', []):
                        if page_result.get('status') == 'SUCCESS':
                            passport_data = schemas.PassportCreate(
                                **page_result['data'],
                                destination=destination 
                            )
                            crud.create_user_passport(db=db, passport=passport_data, user_id=user_id)
                            success_count += 1
                        else:
                            failures.append({
                                "page": page_result.get('page_number', 'N/A'),
                                "error": page_result.get('error', 'Unknown parsing error')
                            })
                finally:
                    db.close()

                final_status = {
                    'status': 'COMPLETE',
                    'filename': original_filename,
                    'successful_pages': success_count,
                    'failed_pages': failures
                }
                return final_status

            elif result['status'] == 'FAILURE':
                logger.error(f"Google operation {google_operation_name} failed: {result.get('error')}")
                raise Exception(f"Google Vision API Error: {result.get('error', 'Unknown error')}")
            
            poll_count += 1
            time.sleep(5)
        
        # Handle timeout scenario
        logger.error(f"Task {self.request.id} timed out after {max_poll_attempts} polling attempts.")
        raise Exception("OCR processing timed out. The operation may still be running on Google's servers.")

    except Exception as e:
        logger.error(f"Error in Celery task {self.request.id}: {e}", exc_info=True)
        # Don't re-raise if task was cancelled
        if was_cancelled or self.is_aborted():
            return {'status': 'CANCELLED', 'detail': 'Task was cancelled during error handling.'}
        raise e
    finally:
        logger.info(f"Cleaning up resources for task {self.request.id}.")
        
        # Always check current cancellation status in cleanup
        is_currently_cancelled = self.is_aborted() or was_cancelled
        
        # Cancel Google operation if task was cancelled
        if is_currently_cancelled and google_operation_name:
            logger.info(f"Task was cancelled, cancelling Google operation {google_operation_name}")
            ocr_service.cancel_google_ocr_operation(google_operation_name)
        
        # Always clean up GCS source file
        if gcs_source_uri:
            try:
                ocr_service._delete_from_gcs(gcs_source_uri)
            except Exception as cleanup_error:
                logger.error(f"Failed to delete GCS source file {gcs_source_uri}: {cleanup_error}")
        
        # Always clean up local temp file
        if file_path and os.path.exists(file_path):
            try:
                os.remove(file_path)
                logger.info(f"Cleaned up temporary file: {file_path}")
            except Exception as cleanup_error:
                logger.error(f"Failed to delete temp file {file_path}: {cleanup_error}")


# --------------- END OF FILE: backend/celery_worker.py ---------------

# --------------- START OF FILE: frontend/src/App.jsx ---------------

// frontend/src/App.jsx

import React, { useState, useEffect, useCallback, useRef } from 'react';

const API_URL = '/api';

// --- STYLES COMPONENT (Integrated, with NEW styles for progress bars) ---
const GlobalStyles = () => (
    <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        :root {
            --primary-color: #2a6fdb; --primary-hover: #1e5a9b; --secondary-color: #6c757d;
            --background-color: #f8f9fa; --surface-color: #ffffff; --text-color: #212529;
            --border-color: #dee2e6; --danger-color: #dc3545; --danger-hover: #a71d2a;
            --success-color: #198754; --warning-color: #ffc107; --font-family: 'Inter', sans-serif;
        }
        body { font-family: var(--font-family); background-color: var(--background-color); color: var(--text-color); margin: 0; line-height: 1.6; }
        .container { max-width: 1200px; margin: 0 auto; padding: 2rem; }
        .app-header { display: flex; justify-content: space-between; align-items: center; background-color: var(--surface-color); padding: 1.5rem 2rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05); margin-bottom: 2rem; }
        .app-header h1 { font-size: 2rem; font-weight: 700; color: var(--primary-color); margin: 0; }
        .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease-in-out; text-align: center; }
        .btn:disabled { background-color: var(--secondary-color); cursor: not-allowed; opacity: 0.7; }
        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-hover); transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .btn-danger { background-color: var(--danger-color); color: white; }
        .btn-danger:hover:not(:disabled) { background-color: var(--danger-hover); }
        .form-container { background-color: var(--surface-color); padding: 2.5rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); max-width: 500px; margin: 2rem auto; }
        .form-container h2 { text-align: center; margin-bottom: 2rem; font-size: 1.75rem; }
        .form-group { margin-bottom: 1.5rem; }
        .form-group label { display: block; margin-bottom: 0.5rem; font-weight: 500; color: var(--secondary-color); }
        .form-input { width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; font-size: 1rem; box-sizing: border-box; }
        .form-input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(42, 111, 219, 0.2); }
        .form-checkbox { width: 1.25rem; height: 1.25rem; cursor: pointer; }
        .password-container { position: relative; display: flex; align-items: center; }
        .password-container .form-input { padding-right: 40px; }
        .password-toggle-btn { position: absolute; right: 10px; background: none; border: none; cursor: pointer; color: var(--secondary-color); padding: 0; display: flex; align-items: center; justify-content: center; }
        .error-message { background-color: rgba(220, 53, 69, 0.1); color: var(--danger-color); padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; text-align: center; }
        .success-message { background-color: rgba(25, 135, 84, 0.1); color: var(--success-color); padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; text-align: center; }
        .info-message { background-color: #eef2f7; color: #334d6e; padding: 1rem; border-radius: 8px; }
        .dashboard-layout { display: grid; grid-template-columns: 250px 1fr; gap: 2rem; }
        .dashboard-nav { background-color: var(--surface-color); padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); align-self: start; }
        .dashboard-nav h3 { margin-top: 0; font-size: 1.25rem; }
        .nav-menu { display: flex; flex-direction: column; gap: 0.5rem; }
        .nav-button { text-align: left; padding: 0.75rem 1rem; border: none; background-color: transparent; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: 500; width: 100%; transition: background-color 0.2s, color 0.2s; }
        .nav-button:hover { background-color: #f1f3f5; }
        .nav-button.active { background-color: var(--primary-color); color: white; }
        .dashboard-content { background-color: var(--surface-color); padding: 2rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); }
        .dashboard-content h2 { margin-top: 0; margin-bottom: 2rem; font-size: 1.75rem; }
        .table-container { overflow-x: auto; border: 1px solid var(--border-color); border-radius: 12px; }
        .table { width: 100%; border-collapse: collapse; }
        .table th, .table td { padding: 1rem; text-align: left; border-bottom: 1px solid var(--border-color); white-space: normal; }
        .table thead th { background-color: #f8f9fa; font-weight: 600; }
        .table tbody tr:last-child td { border-bottom: none; }
        .table tbody tr:hover { background-color: #f1f3f5; }
        .filter-bar { display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; }
        .capitalize { text-transform: capitalize; }
        .text-center { text-align: center; }
        .mt-1 { margin-top: 1rem; }
        .mt-2 { margin-top: 2rem; }
        .mb-1 { margin-bottom: 1rem; }
        .mb-2 { margin-bottom: 2rem; }
        .results-container { margin-top: 2rem; }
        .results-summary { font-size: 1.1rem; font-weight: 600; margin-bottom: 1rem; }
        .results-list { list-style-type: none; padding: 0; max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; }
        .results-list li { display: flex; align-items: center; padding: 0.75rem 1rem; border-bottom: 1px solid var(--border-color); }
        .results-list li:last-child { border-bottom: none; }
        .result-icon { margin-right: 1rem; }
        .result-success .result-icon { color: var(--success-color); }
        .result-failure .result-icon { color: var(--danger-color); }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--surface-color); padding: 2.5rem; border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.15); width: 90%; max-width: 450px; }
        .modal-header { margin-bottom: 1.5rem; }
        .modal-header h3 { margin: 0; font-size: 1.5rem; }
        .modal-body { margin-bottom: 2rem; font-size: 1rem; color: var(--secondary-color); }
        .modal-footer { display: flex; justify-content: flex-end; gap: 1rem; }
        .notification { position: fixed; top: 20px; right: 20px; padding: 1rem 1.5rem; border-radius: 8px; color: white; z-index: 1001; box-shadow: 0 4px 12px rgba(0,0,0,0.1); animation: fadeInOut 4s ease-in-out; }
        .notification.error { background-color: var(--danger-color); }
        @keyframes fadeInOut { 0% { opacity: 0; transform: translateY(-10px); } 10% { opacity: 1; transform: translateY(0); } 90% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-10px); } }

        /* --- NEW STYLES FOR UPLOADER --- */
        .upload-list { list-style: none; padding: 0; margin-top: 1.5rem; }
        .upload-item { display: flex; align-items: center; gap: 1rem; padding: 1rem; border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 1rem; }
        .upload-item-info { flex-grow: 1; }
        .upload-item-info p { margin: 0; font-weight: 500; }
        .upload-item-info small { color: var(--secondary-color); text-transform: capitalize; }
        .progress-bar-container { width: 100%; background-color: #e9ecef; border-radius: 8px; overflow: hidden; height: 10px; margin-top: 0.5rem; }
        .progress-bar { height: 100%; width: 0%; background-color: var(--primary-color); transition: width 0.3s ease-in-out; }
        .progress-bar.processing { animation: pulse 2s infinite; }
        .progress-bar.success { background-color: var(--success-color); }
        .progress-bar.failure { background-color: var(--danger-color); }
        .progress-bar.cancelled { background-color: var(--secondary-color); }
        @keyframes pulse { 0% { background-color: #a8c5f0; } 50% { background-color: var(--primary-color); } 100% { background-color: #a8c5f0; } }

    `}</style>
);

const columnTranslations = {
    first_name: 'Prénom', last_name: 'Nom de famille', birth_date: 'Date de Naissance',
    delivery_date: 'Date de Délivrance', expiration_date: "Date d'Expiration", nationality: 'Nationalité',
    passport_number: 'Numéro de Passeport', confidence_score: 'Score de Confiance', email: 'Email',
    phone_number: 'Numéro de Téléphone', user_name: "Nom d'Utilisateur", role: 'Rôle',
    destination: 'Destination', token: 'Jeton', expires_at: 'Expire Le', is_used: 'Utilisé', actions: 'Actions'
};

const EyeIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>);
const EyeOffIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>);
function PasswordInput({ value, onChange, name, placeholder, required = false }) {
    const [showPassword, setShowPassword] = useState(false);
    return (
        <div className="password-container">
            <input type={showPassword ? 'text' : 'password'} name={name} value={value} onChange={onChange} className="form-input" placeholder={placeholder} required={required} autoComplete="new-password" />
            <button type="button" className="password-toggle-btn" onClick={() => setShowPassword(!showPassword)} aria-label={showPassword ? 'Cacher le mot de passe' : 'Afficher le mot de passe'}>
                {showPassword ? <EyeOffIcon /> : <EyeIcon />}
            </button>
        </div>
    );
}

function Modal({ isOpen, onClose, onConfirm, title, children }) {
    if (!isOpen) return null;
    return (
        <div className="modal-overlay" onClick={onClose}>
            <div className="modal-content" onClick={e => e.stopPropagation()}>
                <div className="modal-header"><h3>{title}</h3></div>
                <div className="modal-body">{children}</div>
                <div className="modal-footer">
                    <button onClick={onClose} className="btn" style={{ backgroundColor: 'var(--secondary-color)', color: 'white' }}>Annuler</button>
                    <button onClick={onConfirm} className="btn btn-danger">Confirmer</button>
                </div>
            </div>
        </div>
    );
}

function Notification({ message, type, onClear }) {
    useEffect(() => {
        const timer = setTimeout(() => { onClear(); }, 4000);
        return () => clearTimeout(timer);
    }, [onClear]);

    if (!message) return null;
    return <div className={`notification ${type}`}>{message}</div>;
}

export default function App() {
    const [token, setToken] = useState(localStorage.getItem('token'));
    const [user, setUser] = useState(null);
    const [view, setView] = useState('login');
    const logout = useCallback(() => { localStorage.removeItem('token'); setToken(null); setUser(null); window.history.pushState({}, '', '/'); setView('login'); }, []);
    const fetchUser = useCallback(async () => {
        const currentToken = localStorage.getItem('token');
        if (currentToken) {
            try {
                const response = await fetch(`${API_URL}/users/me`, { headers: { 'Authorization': `Bearer ${currentToken}` } });
                if (response.ok) { const data = await response.json(); setUser(data); setView('dashboard'); } else { logout(); }
            } catch (error) { console.error("Échec de la récupération de l'utilisateur:", error); logout(); }
        } else {
            const path = window.location.pathname;
            if (path.startsWith('/register/')) { setView('register'); } else { setView('login'); }
        }
    }, [logout]);
    useEffect(() => {
        fetchUser();
        const handlePopState = () => fetchUser();
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
    }, [fetchUser]);
    const renderView = () => {
        const path = window.location.pathname;
        if (view === 'register' || path.startsWith('/register/')) { const registrationToken = path.split('/')[2]; return <RegistrationPage registrationToken={registrationToken} />; }
        switch (view) {
            case 'login': return <Login setToken={setToken} fetchUser={fetchUser} />;
            case 'dashboard': return <Dashboard user={user} logout={logout} token={token} fetchUser={fetchUser} />;
            default: return <Login setToken={setToken} fetchUser={fetchUser} />;
        }
    };
    return (<><GlobalStyles /><div className="container"><header className="app-header"><h1>Gestionnaire de Voyages</h1>{user && <button onClick={logout} className="btn btn-danger">Déconnexion</button>}</header><main>{renderView()}</main></div></>);
}

function Login({ setToken, fetchUser }) {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [isLoading, setIsLoading] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setIsLoading(true);
        const formData = new URLSearchParams({ username, password });
        try {
            const response = await fetch(`${API_URL}/token`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: formData, });
            if (response.ok) {
                const data = await response.json();
                localStorage.setItem('token', data.access_token);
                setToken(data.access_token);
                fetchUser();
            } else {
                if (response.status === 429) {
                    setError("Trop de tentatives de connexion. Veuillez réessayer dans une minute.");
                } else {
                    const errorData = await response.json();
                    setError(errorData.detail || 'Échec de la connexion.');
                }
            }
        } catch (err) {
            setError('Une erreur est survenue. Veuillez réessayer.');
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="form-container">
            <h2>Connexion</h2>
            {error && <p className="error-message">{error}</p>}
            <form onSubmit={handleSubmit}>
                <div className="form-group">
                    <label>Nom d'utilisateur</label>
                    <input type="text" value={username} onChange={e => setUsername(e.target.value)} className="form-input" required />
                </div>
                <div className="form-group">
                    <label>Mot de passe</label>
                    <PasswordInput name="password" value={password} onChange={e => setPassword(e.target.value)} required={true} />
                </div>
                <button type="submit" className="btn btn-primary" style={{ width: '100%' }} disabled={isLoading}>
                    {isLoading ? 'Connexion en cours...' : 'Se connecter'}
                </button>
            </form>
        </div>
    );
}

function RegistrationPage({ registrationToken }) {
    const [formData, setFormData] = useState({ first_name: '', last_name: '', email: '', phone_number: '', user_name: '', password: '' });
    const [error, setError] = useState('');
    const [success, setSuccess] = useState('');
    const [isLoading, setIsLoading] = useState(true);
    useEffect(() => {
        const fetchInvitation = async () => {
            if (!registrationToken) { setError("Aucun jeton d'inscription fourni."); setIsLoading(false); return; }
            try {
                const response = await fetch(`${API_URL}/invitations/${registrationToken}`);
                if (response.ok) { const data = await response.json(); setFormData(prev => ({ ...prev, email: data.email })); } else { setError((await response.json()).detail || "Lien d'inscription invalide ou expiré."); }
            } catch (err) { setError("Une erreur est survenue lors de la validation du lien d'inscription."); } finally { setIsLoading(false); }
        };
        fetchInvitation();
    }, [registrationToken]);
    const handleChange = (e) => setFormData({ ...formData, [e.target.name]: e.target.value });
    const handleSubmit = async (e) => {
        e.preventDefault(); setError(''); setSuccess('');
        try {
            const response = await fetch(`${API_URL}/users/?token=${registrationToken}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(formData) });
            if (response.ok) { setSuccess('Inscription réussie ! Vous allez être redirigé vers la page de connexion.'); setTimeout(() => { window.history.pushState({}, '', '/'); window.location.reload(); }, 2000); } else { setError((await response.json()).detail || "Échec de l'inscription."); }
        } catch (err) { setError("Une erreur est survenue lors de l'inscription."); }
    };
    if (isLoading) return <p className="info-message">Chargement...</p>;
    if (success) return <div className="form-container"><p className="success-message">{success}</p></div>
    return (<div className="form-container"><h2>Créer un nouveau compte</h2>{error && <p className="error-message">{error}</p>}<form onSubmit={handleSubmit}><div className="form-group"><label>Prénom</label><input type="text" name="first_name" value={formData.first_name} onChange={handleChange} className="form-input" required /></div><div className="form-group"><label>Nom de famille</label><input type="text" name="last_name" value={formData.last_name} onChange={handleChange} className="form-input" required /></div><div className="form-group"><label>Email</label><input type="email" name="email" value={formData.email} onChange={handleChange} className="form-input" required readOnly /></div><div className="form-group"><label>Numéro de téléphone</label><input type="text" name="phone_number" value={formData.phone_number} onChange={handleChange} className="form-input" required /></div><div className="form-group"><label>Nom d'utilisateur</label><input type="text" name="user_name" value={formData.user_name} onChange={handleChange} className="form-input" required /></div><div className="form-group"><label>Mot de passe</label><PasswordInput name="password" value={formData.password} onChange={handleChange} required={true} /></div><button type="submit" className="btn btn-primary" style={{ width: '100%' }}>S'inscrire</button></form></div>);
}

function Dashboard({ user, token, fetchUser }) {
    const [activeTab, setActiveTab] = useState('passports');
    const [filterableUsers, setFilterableUsers] = useState([]);
    const [userSpecificDestinations, setUserSpecificDestinations] = useState([]);

    const fetchAdminData = useCallback(async () => {
        if (user.role !== 'admin') return;
        try {
            const filterableUsersRes = await fetch(`${API_URL}/admin/filterable-users`, { headers: { 'Authorization': `Bearer ${token}` } });
            if (filterableUsersRes.ok) setFilterableUsers(await filterableUsersRes.json());
        } catch (error) { console.error("Échec de la récupération des données admin:", error); }
    }, [user, token]);

    const fetchUserDestinations = useCallback(async () => {
        try {
            const response = await fetch(`${API_URL}/destinations/`, { headers: { 'Authorization': `Bearer ${token}` } });
            if (response.ok) setUserSpecificDestinations(await response.json());
        } catch (error) { console.error("Échec de la récupération des destinations de l'utilisateur:", error); }
    }, [token]);

    useEffect(() => { fetchAdminData(); fetchUserDestinations(); }, [fetchAdminData, fetchUserDestinations]);

    const renderTabContent = () => {
        const passportFilterConfig = user.role === 'admin'
            ? [{ name: 'user_filter', placeholder: 'Filtrer par Utilisateur', options: filterableUsers, getOptionValue: (o) => o.id, getOptionLabel: (o) => `${o.first_name} ${o.last_name} (${o.user_name})` }]
            : null;
        const voyageFilterConfig = user.role === 'admin'
            ? [{ name: 'user_filter', placeholder: 'Filtrer par Utilisateur', options: filterableUsers, getOptionValue: (o) => o.id, getOptionLabel: (o) => `${o.first_name} ${o.last_name} (${o.user_name})` }]
            : null;
        const passportFields = { first_name: 'text', last_name: 'text', birth_date: 'date', delivery_date: 'date', expiration_date: 'date', nationality: 'text', passport_number: 'text', destination: 'text', confidence_score: 'number' };

        switch (activeTab) {
            case 'account': return <AccountEditor user={user} token={token} fetchUser={fetchUser} />;
            case 'passports': return <CrudManager title="Gérer les Passeports" endpoint="passports" token={token} user={user} fields={passportFields} filterConfig={passportFilterConfig} />;
            case 'voyages': return <CrudManager title="Gérer les Voyages" endpoint="voyages" token={token} user={user} fields={{ destination: 'text' }} filterConfig={voyageFilterConfig} />;
            case 'tools_export': return <ToolsAndExportPanel token={token} user={user} adminUsers={filterableUsers} userDestinations={userSpecificDestinations} />;
            case 'users': return user.role === 'admin' ? <CrudManager title="Gérer les Utilisateurs" endpoint="admin/users" token={token} user={user} fields={{ first_name: 'text', last_name: 'text', email: 'email', phone_number: 'text', user_name: 'text', password: 'password', role: 'text' }} /> : null;
            case 'invitations': return user.role === 'admin' ? <CrudManager title="Gérer les Invitations" endpoint="admin/invitations" token={token} user={user} fields={{ email: 'email', token: 'text', expires_at: 'datetime-local', is_used: 'checkbox' }} /> : null;
            default: return null;
        }
    };
    return (
        <div className="dashboard-layout">
            <nav className="dashboard-nav">
                <h3>Bienvenue, {user.first_name}!</h3>
                <div className="nav-menu">
                    <button onClick={() => setActiveTab('account')} className={`nav-button ${activeTab === 'account' ? 'active' : ''}`}>Mon Compte</button>
                    <button onClick={() => setActiveTab('passports')} className={`nav-button ${activeTab === 'passports' ? 'active' : ''}`}>Passeports</button>
                    <button onClick={() => setActiveTab('voyages')} className={`nav-button ${activeTab === 'voyages' ? 'active' : ''}`}>Voyages</button>
                    <button onClick={() => setActiveTab('tools_export')} className={`nav-button ${activeTab === 'tools_export' ? 'active' : ''}`}>Outils & Exportation</button>
                    {user.role === 'admin' && (
                        <> <hr />
                            <button onClick={() => setActiveTab('users')} className={`nav-button ${activeTab === 'users' ? 'active' : ''}`}>Gérer les Utilisateurs</button>
                            <button onClick={() => setActiveTab('invitations')} className={`nav-button ${activeTab === 'invitations' ? 'active' : ''}`}>Gérer les Invitations</button>
                        </>
                    )}
                </div>
            </nav>
            <div className="dashboard-content">{renderTabContent()}</div>
        </div>
    );
}

function AccountEditor({ user, token, fetchUser }) {
    const [formData, setFormData] = useState({ first_name: '', last_name: '', email: '', phone_number: '', password: '' });
    const [message, setMessage] = useState('');
    useEffect(() => { if (user) setFormData({ first_name: user.first_name, last_name: user.last_name, email: user.email, phone_number: user.phone_number, password: '' }); }, [user]);
    const handleChange = (e) => setFormData({ ...formData, [e.target.name]: e.target.value });
    const handleSubmit = async (e) => {
        e.preventDefault(); setMessage(''); const payload = { ...formData }; if (!payload.password) delete payload.password;
        const response = await fetch(`${API_URL}/users/me`, { method: 'PUT', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` }, body: JSON.stringify(payload) });
        if (response.ok) { setMessage('Compte mis à jour avec succès !'); fetchUser(); } else { setMessage('Échec de la mise à jour du compte.'); }
    };
    return (<div><h2>Modifier Mon Compte</h2>{message && <p className="success-message">{message}</p>}<form onSubmit={handleSubmit}><div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}><div className="form-group"><label>Prénom</label><input type="text" name="first_name" value={formData.first_name} onChange={handleChange} className="form-input" /></div><div className="form-group"><label>Nom de famille</label><input type="text" name="last_name" value={formData.last_name} onChange={handleChange} className="form-input" /></div><div className="form-group"><label>Email</label><input type="email" name="email" value={formData.email} onChange={handleChange} className="form-input" /></div><div className="form-group"><label>Numéro de téléphone</label><input type="text" name="phone_number" value={formData.phone_number} onChange={handleChange} className="form-input" /></div></div><div className="form-group"><label>Nouveau mot de passe (optionnel)</label><PasswordInput name="password" value={formData.password} onChange={handleChange} placeholder="Laisser vide pour conserver le mot de passe actuel" /></div><button type="submit" className="btn btn-primary">Enregistrer les modifications</button></form></div>);
}

function OcrUploader({ token, onUploadSuccess }) {
    const [uploadTasks, setUploadTasks] = useState([]);
    const [destination, setDestination] = useState('');
    const [destinations, setDestinations] = useState([]);
    const pollingIntervals = useRef({});

    useEffect(() => {
        const fetchDestinations = async () => {
            try {
                const response = await fetch(`${API_URL}/destinations/`, { headers: { 'Authorization': `Bearer ${token}` } });
                if (response.ok) setDestinations(await response.json());
            } catch (error) { console.error("Failed to fetch destinations:", error); }
        };
        fetchDestinations();
    }, [token]);

    useEffect(() => {
        return () => {
            Object.values(pollingIntervals.current).forEach(clearInterval);
        };
    }, []);

    const handleFileChange = (e) => {
        const newFiles = Array.from(e.target.files).map(file => ({
            id: `${file.name}-${file.lastModified}`,
            file: file,
            status: 'WAITING', // 'WAITING', 'PENDING', 'PROGRESS', 'SUCCESS', 'FAILURE', 'CANCELLED'
            progress: { status: 'En attente de traitement...' },
            taskId: null,
            result: null
        }));
        setUploadTasks(prev => [...prev, ...newFiles]);
        e.target.value = null; // Reset file input
    };

    const pollTaskStatus = useCallback((taskId, fileId) => {
        pollingIntervals.current[taskId] = setInterval(async () => {
            try {
                const response = await fetch(`${API_URL}/tasks/${taskId}/status`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) throw new Error('Network response was not ok.');
                
                const data = await response.json();

                setUploadTasks(prev => prev.map(task =>
                    task.id === fileId ? { ...task, status: data.status, progress: data.progress || task.progress, result: data.result } : task
                ));

                if (['SUCCESS', 'FAILURE', 'CANCELLED'].includes(data.status)) {
                    clearInterval(pollingIntervals.current[taskId]);
                    delete pollingIntervals.current[taskId];
                    onUploadSuccess(true); // Signal to refresh data in the main view
                }
            } catch (error) {
                console.error("Polling error:", error);
                clearInterval(pollingIntervals.current[taskId]);
                delete pollingIntervals.current[taskId];
                setUploadTasks(prev => prev.map(task =>
                    task.id === fileId ? { ...task, status: 'FAILURE', progress: { status: 'Erreur de suivi.' } } : task
                ));
            }
        }, 5000); // Poll every 5 seconds
    }, [token, onUploadSuccess]);

    const handleSubmit = async () => {
        const filesToUpload = uploadTasks.filter(task => task.status === 'WAITING');
        if (filesToUpload.length === 0) return;

        const formData = new FormData();
        filesToUpload.forEach(task => {
            formData.append('files', task.file);
        });
        if (destination) formData.append('destination', destination);
        
        // Mark files as pending immediately for better UX
        setUploadTasks(prev => prev.map(t => filesToUpload.find(f => f.id === t.id) ? { ...t, status: 'PENDING' } : t));

        try {
            const response = await fetch(`${API_URL}/passports/upload-and-extract/`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}` },
                body: formData
            });

            if (response.status === 202) {
                const data = await response.json(); // Expects { tasks: [{ task_id, filename }] }
                data.tasks.forEach(createdTask => {
                    const matchingFile = filesToUpload.find(f => f.file.name === createdTask.filename);
                    if (matchingFile) {
                        setUploadTasks(prev => prev.map(t =>
                            t.id === matchingFile.id ? { ...t, taskId: createdTask.task_id, status: 'PROGRESS', progress: { status: 'En cours de traitement...' } } : t
                        ));
                        pollTaskStatus(createdTask.task_id, matchingFile.id);
                    }
                });
            } else {
                const errorData = await response.json();
                setUploadTasks(prev => prev.map(t =>
                    filesToUpload.find(f => f.id === t.id) ? { ...t, status: 'FAILURE', progress: { status: errorData.detail || 'Upload failed.' } } : t
                ));
            }
        } catch (err) {
            console.error("Upload error:", err);
            setUploadTasks(prev => prev.map(t =>
                filesToUpload.find(f => f.id === t.id) ? { ...t, status: 'FAILURE', progress: { status: 'Erreur réseau.' } } : t
            ));
        }
    };
    
    const handleCancel = async (taskToCancel) => {
        if (!taskToCancel.taskId) return; // Can't cancel if no task ID yet
        
        clearInterval(pollingIntervals.current[taskToCancel.taskId]);
        delete pollingIntervals.current[taskToCancel.taskId];
        
        try {
            await fetch(`${API_URL}/tasks/${taskToCancel.taskId}/cancel`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}` }
            });
            setUploadTasks(prev => prev.map(task =>
                task.id === taskToCancel.id ? { ...task, status: 'CANCELLED', progress: { status: 'Annulation demandée.'} } : task
            ));
        } catch (error) {
            console.error("Failed to send cancel request:", error);
        }
    };
    
    const handleRemoveTask = (idToRemove) => {
        setUploadTasks(prev => prev.filter(task => task.id !== idToRemove));
    };

    const handleFinishAndClear = () => {
        setUploadTasks([]);
        onUploadSuccess(false); // Close the uploader view
    };

    const isUploading = uploadTasks.some(t => ['PENDING', 'PROGRESS'].includes(t.status));
    const waitingCount = uploadTasks.filter(t => t.status === 'WAITING').length;
    
    const getProgressBarClass = (status) => {
        switch(status) {
            case 'SUCCESS': return 'success';
            case 'FAILURE': return 'failure';
            case 'CANCELLED': return 'cancelled';
            case 'PROGRESS':
            case 'PENDING': return 'processing';
            default: return '';
        }
    }

    return (
        <div className="form-container" style={{ maxWidth: 'none', margin: 0, padding: '2rem' }}>
            <h3>Ajouter des Passeports via Téléchargement</h3>
            <div className="form-group">
                <label>Destination (Optionnel)</label>
                <input type="text" value={destination} onChange={(e) => setDestination(e.target.value)} className="form-input" list="destination-datalist-ocr" placeholder="Appliquer à tous les passeports des fichiers" autoComplete="off" />
                <datalist id="destination-datalist-ocr">{destinations.map(dest => <option key={dest} value={dest} />)}</datalist>
            </div>
            <div className="form-group">
                <label>Documents PDF (plusieurs fichiers possibles)</label>
                <input type="file" onChange={handleFileChange} accept="application/pdf" className="form-input" multiple disabled={isUploading} />
            </div>

            <ul className="upload-list">
                {uploadTasks.map(task => (
                    <li key={task.id} className="upload-item">
                        <div className="upload-item-info">
                            <p>{task.file.name}</p>
                            <small>{task.progress?.status || task.status}</small>
                            <div className="progress-bar-container">
                                <div
                                    className={`progress-bar ${getProgressBarClass(task.status)}`}
                                    style={{ width: ['SUCCESS', 'FAILURE', 'CANCELLED'].includes(task.status) ? '100%' : (['PROGRESS', 'PENDING'].includes(task.status) ? '50%' : '0%') }}
                                ></div>
                            </div>
                            {task.status === 'SUCCESS' && task.result && (
                                <small style={{color: 'var(--success-color)'}}>
                                    Succès: {task.result.successful_pages}, Échecs: {task.result.failed_pages?.length || 0}
                                </small>
                            )}
                             {task.status === 'FAILURE' && (
                                <small style={{color: 'var(--danger-color)'}}>
                                    Échec: {task.result || 'Une erreur est survenue.'}
                                </small>
                            )}
                        </div>
                        {['PENDING', 'PROGRESS'].includes(task.status) && (
                            <button onClick={() => handleCancel(task)} className="btn btn-danger">Annuler</button>
                        )}
                        {['SUCCESS', 'FAILURE', 'CANCELLED', 'WAITING'].includes(task.status) && (
                            <button onClick={() => handleRemoveTask(task.id)} className="btn" style={{backgroundColor: 'transparent', color: 'var(--danger-color)'}}>✕</button>
                        )}
                    </li>
                ))}
            </ul>

            <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '1rem', marginTop: '2rem' }}>
                <button onClick={handleFinishAndClear} className="btn" style={{ backgroundColor: 'var(--secondary-color)', color: 'white' }}>
                    Terminé
                </button>
                <button onClick={handleSubmit} className="btn btn-primary" disabled={isUploading || waitingCount === 0}>
                    {isUploading ? 'Traitement en cours...' : `Lancer le traitement (${waitingCount})`}
                </button>
            </div>
        </div>
    );
}

function CrudManager({ title, endpoint, token, user, fields, filterConfig }) {
    const [items, setItems] = useState([]);
    const [editingItem, setEditingItem] = useState(null);
    const [isCreating, setIsCreating] = useState(false);
    const [filters, setFilters] = useState({});
    const [showOcrUploader, setShowOcrUploader] = useState(false);
    const [dynamicDestinations, setDynamicDestinations] = useState([]);
    const [selectedItems, setSelectedItems] = useState([]);
    const selectAllCheckboxRef = useRef(null);

    const [modalState, setModalState] = useState({ isOpen: false, title: '', message: '', onConfirm: () => { } });
    const [notification, setNotification] = useState({ message: '', type: '' });

    const showNotification = (message, type = 'error') => {
        setNotification({ message, type });
    };

    const fetchDestinationsForUser = useCallback(async (userId) => {
        const query = userId ? `?user_id=${userId}` : '';
        try {
            const response = await fetch(`${API_URL}/destinations/${query}`, { headers: { 'Authorization': `Bearer ${token}` } });
            if (response.ok) setDynamicDestinations(await response.json());
        } catch (error) { console.error("Échec de la récupération des destinations:", error); }
    }, [token]);

    useEffect(() => { if (user.role === 'admin' && endpoint === 'passports') fetchDestinationsForUser(null); }, [user, endpoint, fetchDestinationsForUser]);

    const handleFilterChange = (filterName, value) => {
        const newFilters = { ...filters, [filterName]: value };
        if (user.role === 'admin' && filterName === 'user_filter') {
            fetchDestinationsForUser(value || null);
            newFilters.voyage_filter = '';
        }
        setFilters(newFilters);
    };

    const fetchData = useCallback(async () => {
        const activeFilters = Object.fromEntries(Object.entries(filters).filter(([, v]) => v));
        const query = new URLSearchParams(activeFilters);
        const url = `${API_URL}/${endpoint}/?${query.toString()}`;
        try {
            const response = await fetch(url, { headers: { 'Authorization': `Bearer ${token}` } });
            if (response.ok) setItems(await response.json());
            else console.error("Échec de la récupération des données pour", endpoint);
        } catch (error) { console.error("Erreur lors de la récupération des données:", error); }
    }, [endpoint, token, filters]);

    useEffect(() => { fetchData(); }, [fetchData]);

    useEffect(() => {
        if (selectAllCheckboxRef.current) {
            const allVisibleSelected = items.length > 0 && selectedItems.length === items.length;
            const someVisibleSelected = selectedItems.length > 0 && selectedItems.length < items.length;
            selectAllCheckboxRef.current.checked = allVisibleSelected;
            selectAllCheckboxRef.current.indeterminate = someVisibleSelected;
        }
    }, [selectedItems, items]);

    const handleSelect = (id) => setSelectedItems(prev => prev.includes(id) ? prev.filter(itemId => itemId !== id) : [...prev, id]);
    const handleSelectAll = (e) => setSelectedItems(e.target.checked ? items.map(item => item.id) : []);

    const confirmMultipleDelete = () => {
        if (selectedItems.length === 0) return;
        setModalState({
            isOpen: true,
            title: 'Confirmer la Suppression',
            message: `Êtes-vous sûr de vouloir supprimer les ${selectedItems.length} passeports sélectionnés ? Cette action est irréversible.`,
            onConfirm: () => handleMultipleDelete()
        });
    };

    const handleMultipleDelete = async () => {
        try {
            const response = await fetch(`${API_URL}/${endpoint}/delete-multiple`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                body: JSON.stringify({ ids: selectedItems }),
            });
            if (response.ok || response.status === 204) {
                setSelectedItems([]);
                fetchData();
            } else {
                const errorData = await response.json();
                showNotification(`Échec de la suppression : ${errorData.detail || 'Erreur du serveur'}`);
            }
        } catch (error) {
            console.error("Erreur lors de la suppression multiple :", error);
            showNotification("Une erreur de réseau est survenue lors de la suppression.");
        } finally {
            setModalState({ isOpen: false, title: '', message: '', onConfirm: () => { } });
        }
    };

    const handleSave = (fromOcr = false) => {
        if (!fromOcr) {
            setEditingItem(null);
            setIsCreating(false);
            setShowOcrUploader(false);
        }
        fetchData();
    };

    const startCreating = () => {
        let newItem = Object.keys(fields).reduce((acc, key) => ({ ...acc, [key]: '' }), {});
        if (endpoint === 'admin/users') newItem.role = 'user';
        if (endpoint === 'admin/invitations') newItem = { email: '' };
        setEditingItem(newItem);
        setIsCreating(true);
    };

    if (showOcrUploader) return <OcrUploader token={token} onUploadSuccess={handleSave} />
    if (editingItem) return <CrudForm item={editingItem} isCreating={isCreating} onSave={handleSave} onCancel={() => setEditingItem(null)} fields={fields} endpoint={endpoint} token={token} />;
    const displayFields = { ...fields };
    if (endpoint === 'admin/users') delete displayFields.password;
    if (endpoint === 'admin/invitations' && isCreating) delete displayFields.token;
    if (endpoint === 'passports') delete displayFields.destination;

    return (
        <div>
            <Notification message={notification.message} type={notification.type} onClear={() => setNotification({ message: '', type: '' })} />
            <Modal isOpen={modalState.isOpen} onClose={() => setModalState({ ...modalState, isOpen: false })} onConfirm={modalState.onConfirm} title={modalState.title}>
                <p>{modalState.message}</p>
            </Modal>

            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }} className="mb-2">
                <h2>{title}</h2>
                <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
                    {endpoint === 'passports' && (
                        <button onClick={confirmMultipleDelete} className="btn btn-danger" disabled={selectedItems.length === 0}>
                            Supprimer ({selectedItems.length})
                        </button>
                    )}
                    {endpoint === 'passports' && (
                        <button onClick={() => setShowOcrUploader(true)} className="btn btn-primary" style={{ backgroundColor: 'var(--success-color)' }}>+ Ajouter par Téléchargement</button>
                    )}
                    <button onClick={startCreating} className="btn btn-primary">{endpoint === 'passports' ? '+ Ajouter Manuellement' : '+ Ajouter'}</button>
                </div>
            </div>

            {endpoint.includes('users') && !filterConfig && (<div className="filter-bar mb-2"><div className="form-group" style={{ flex: 1, marginBottom: 0 }}><input type="text" name="name_filter" placeholder="Filtrer par Nom, Nom d'utilisateur ou Email" onChange={(e) => handleFilterChange(e.target.name, e.target.value)} className="form-input" autoComplete="off"/></div></div>)}
            {filterConfig && (
                <div className="filter-bar mb-2">
                    {filterConfig.map(filter => (<ComboBoxFilter key={filter.name} {...filter} onChange={handleFilterChange} />))}
                    {user.role === 'admin' && endpoint === 'passports' && (<ComboBoxFilter key="voyage_filter" name="voyage_filter" placeholder="Filtrer par Destination" options={dynamicDestinations.map(d => ({ destination: d }))} getOptionValue={(o) => o.destination} getOptionLabel={(o) => o.destination} onChange={handleFilterChange} />)}
                </div>
            )}

            <div className="table-container">
                <table className="table">
                    <thead>
                        <tr>
                            {endpoint === 'passports' && (<th style={{ width: '1%' }}><input type="checkbox" ref={selectAllCheckboxRef} className="form-checkbox" onChange={handleSelectAll} disabled={items.length === 0}/></th>)}
                            {Object.keys(displayFields).map(field => (<th key={field}>{columnTranslations[field] || field.replace(/_/g, ' ')}</th>))}
                            <th>{columnTranslations['actions']}</th>
                        </tr>
                    </thead>
                    <tbody>
                        {items.map(item => (
                            <tr key={item.id} style={{ backgroundColor: selectedItems.includes(item.id) ? '#eef2f7' : 'transparent' }}>
                                {endpoint === 'passports' && (<td><input type="checkbox" className="form-checkbox" checked={selectedItems.includes(item.id)} onChange={() => handleSelect(item.id)}/></td>)}
                                {Object.keys(displayFields).map(field => {
                                    let cellValue = item[field];
                                    if (field === 'confidence_score' && typeof cellValue === 'number') { cellValue = `${(cellValue * 100).toFixed(2)}%`; }
                                    return <td key={field}>{String(cellValue)}</td>
                                })}
                                <td>
                                    <button onClick={() => setEditingItem(item)} className="btn" style={{ backgroundColor: 'var(--warning-color)', color: 'black', marginRight: '0.5rem' }}>Modifier</button>
                                    {endpoint !== 'passports' && <button onClick={() => {/* Implement single delete with modal if needed */}} className="btn btn-danger">Supprimer</button>}
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );
}

function CrudForm({ item, isCreating, onSave, onCancel, fields, endpoint, token }) {
    const [formData, setFormData] = useState(item);
    const [destinations, setDestinations] = useState([]);
    const [error, setError] = useState('');
    useEffect(() => {
        const initialData = { ...item };
        Object.entries(fields).forEach(([key, type]) => { if (type === 'datetime-local' && initialData[key]) { initialData[key] = new Date(initialData[key]).toISOString().slice(0, 16); } });
        if (endpoint === 'passports' && !isCreating && item.voyages && item.voyages.length > 0) { initialData.destination = item.voyages[0].destination; }
        setFormData(initialData);
    }, [item, fields, endpoint, isCreating]);
    
    useEffect(() => {
        if (endpoint === 'passports') {
            const fetchDestinations = async () => {
                try {
                    const response = await fetch(`${API_URL}/destinations/`, { headers: { 'Authorization': `Bearer ${token}` } });
                    if (response.ok) setDestinations(await response.json());
                } catch (error) { console.error("Échec de la récupération des destinations:", error); }
            };
            fetchDestinations();
        }
    }, [endpoint, token]);

    const handleChange = (e) => { const { name, value, type, checked } = e.target; setFormData({ ...formData, [name]: type === 'checkbox' ? checked : value }); };
    const handleSubmit = async (e) => {
        e.preventDefault(); setError('');
        let url = isCreating ? `${API_URL}/${endpoint}/` : `${API_URL}/${endpoint}/${item.id}`;
        let method = isCreating ? 'POST' : 'PUT';
        let body = { ...formData };
        if (body.confidence_score === '') { body.confidence_score = null; }
        if (endpoint === 'admin/invitations' && isCreating) body = { email: formData.email };
        if (endpoint === 'admin/users' && !isCreating && !body.password) delete body.password;
        const response = await fetch(url, { method, headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` }, body: JSON.stringify(body), });
        if (response.ok) { onSave(); } else { const errorData = await response.json(); setError(errorData.detail || "Échec de l'enregistrement de l'élément."); }
    };
    const formFields = { ...fields };
    if (formFields.confidence_score) { delete formFields.confidence_score; }
    if (isCreating && endpoint === 'admin/invitations') { return (<form onSubmit={handleSubmit} className="form-container" style={{ maxWidth: 'none', margin: 0, padding: '2rem' }}><h3>Créer une nouvelle invitation</h3>{error && <p className="error-message">{error}</p>}<div className="form-group"><label>Email</label><input type="email" name="email" value={formData.email || ''} onChange={handleChange} className="form-input" required /></div><div style={{ display: 'flex', justifyContent: 'flex-end', gap: '1rem', marginTop: '2rem' }}><button type="button" onClick={onCancel} className="btn" style={{ backgroundColor: 'var(--secondary-color)', color: 'white' }}>Annuler</button><button type="submit" className="btn btn-primary">Enregistrer</button></div></form>) }
    return (<form onSubmit={handleSubmit} className="form-container" style={{ maxWidth: 'none', margin: 0, padding: '2rem' }}><h3>{isCreating ? 'Créer' : 'Modifier'} l'élément</h3>{error && <p className="error-message">{error}</p>}<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>{Object.entries(formFields).map(([key, type]) => (<div className="form-group" key={key}><label>{columnTranslations[key] || key.replace(/_/g, ' ')}</label>{key === 'password' ? (<PasswordInput name={key} value={formData[key] || ''} onChange={handleChange} placeholder={!isCreating ? 'Laisser vide pour conserver' : ''} required={isCreating} />) : key === 'destination' ? (<><input type="text" name="destination" value={formData.destination || ''} onChange={handleChange} className="form-input" list="destination-datalist-form" placeholder="Choisissez ou créez une destination" autoComplete="off" /><datalist id="destination-datalist-form">{destinations.map(dest => <option key={dest} value={dest} />)}</datalist></>) : type === 'checkbox' ? (<input type="checkbox" name={key} checked={!!formData[key]} onChange={handleChange} className="form-checkbox" />) : (<input type={type} name={key} value={formData[key] || ''} onChange={handleChange} className="form-input" required={key !== 'destination' && key !== 'token' && type !== 'checkbox'} readOnly={(key === 'token')} />)}</div>))}</div><div style={{ display: 'flex', justifyContent: 'flex-end', gap: '1rem', marginTop: '2rem' }}><button type="button" onClick={onCancel} className="btn" style={{ backgroundColor: 'var(--secondary-color)', color: 'white' }}>Annuler</button><button type="submit" className="btn btn-primary">Enregistrer</button></div></form>);
}

function ToolsAndExportPanel({ token, user, adminUsers, userDestinations }) {
    const [filters, setFilters] = useState({ user_id: '', destination: '' });
    const [previewData, setPreviewData] = useState(null);
    const [inviteEmail, setInviteEmail] = useState('');
    const [inviteMsg, setInviteMsg] = useState('');
    const [invitationLink, setInvitationLink] = useState('');
    const [notification, setNotification] = useState({ message: '', type: '' });

    const showNotification = (message, type = 'error') => { setNotification({ message, type }); };
    const handleFilterChange = (name, value) => { setFilters(prev => ({ ...prev, [name]: value })); setPreviewData(null); };

    const getFilteredData = async () => {
        const activeFilters = Object.fromEntries(Object.entries(filters).filter(([, v]) => v));
        if (user.role !== 'admin') delete activeFilters.user_id;
        const query = new URLSearchParams(activeFilters).toString();
        try {
            const response = await fetch(`${API_URL}/export/data?${query}`, { headers: { 'Authorization': `Bearer ${token}` } });
            if (!response.ok) {
                const err = await response.json();
                showNotification(`Échec de la récupération des données: ${err.detail}`);
                return null;
            }
            return response;
        } catch (error) { showNotification('Une erreur est survenue lors de la récupération des données.'); return null; }
    };

    const handlePreview = async () => {
        const response = await getFilteredData();
        if (response) {
            const csvText = await response.text();
            if (!csvText) { setPreviewData([]); return; }
            const rows = csvText.trim().split('\n');
            const headers = rows[0].split(',');
            const data = rows.slice(1).map(row => { const values = row.split(','); return headers.reduce((obj, h, i) => ({ ...obj, [h]: values[i] }), {}); });
            setPreviewData(data);
        }
    };

    const handleExport = async () => {
        const response = await getFilteredData();
        if (response) {
            const blob = await response.blob();
            const contentDisposition = response.headers.get('content-disposition');
            const filename = contentDisposition?.match(/filename="?(.+)"?/)?.[1] || 'passports_export.csv';
            const url = window.URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
            setPreviewData(null);
        }
    };

    const handleInvite = async () => {
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(inviteEmail)) { setInviteMsg('Veuillez entrer une adresse email valide.'); return; }
        setInviteMsg('Génération du lien...'); setInvitationLink('');
        try {
            const response = await fetch(`${API_URL}/admin/invitations`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` }, body: JSON.stringify({ email: inviteEmail }), });
            const data = await response.json();
            if (response.ok) { const link = `${window.location.origin}/register/${data.token}`; setInvitationLink(link); setInviteMsg('Lien généré. Copiez-le et envoyez-le à l\'utilisateur.'); } else { setInviteMsg(data.detail || 'Échec de la création de l\'invitation.'); }
        } catch (error) { setInviteMsg('Une erreur est survenue.'); }
    };

    return (
        <div>
            <Notification message={notification.message} type={notification.type} onClear={() => setNotification({ message: '', type: '' })} />
            <h2>Outils & Exportation</h2>
            {user.role === 'admin' && (
                <div className="form-container" style={{ maxWidth: 'none', margin: 0, padding: '2rem', marginBottom: '2rem' }}>
                    <h3>Inviter un nouvel utilisateur</h3>
                    <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
                        <input type="email" placeholder="Entrez l'email de l'utilisateur" value={inviteEmail} onChange={e => setInviteEmail(e.target.value)} className="form-input" style={{ flexGrow: 1 }} />
                        <button onClick={handleInvite} className="btn btn-primary" style={{ backgroundColor: 'var(--warning-color)', color: 'black' }}>Générer le lien</button>
                    </div>
                    {inviteMsg && <p className="info-message mt-1">{inviteMsg}</p>}
                    {invitationLink && (<div className="mt-1"><input type="text" readOnly value={invitationLink} className="form-input" onClick={e => e.target.select()} /></div>)}
                </div>
            )}
            <div className="form-container" style={{ maxWidth: 'none', margin: 0, padding: '2rem' }}>
                <h3>Filtrer et Exporter les Données des Passeports</h3>
                <div className="filter-bar mb-1">
                    {user.role === 'admin' && (<ComboBoxFilter name="user_id" placeholder="Filtrer par Utilisateur" options={adminUsers} getOptionValue={(o) => o.id} getOptionLabel={(o) => `${o.first_name} ${o.last_name} (${o.user_name})`} onChange={handleFilterChange} />)}
                    <ComboBoxFilter name="destination" placeholder="Filtrer par Destination" options={userDestinations.map(d => ({ destination: d }))} getOptionValue={(o) => o.destination} getOptionLabel={(o) => o.destination} onChange={handleFilterChange} />
                </div>
                <button onClick={handlePreview} className="btn btn-primary">Aperçu des Données</button>
                {previewData && (<><PreviewTable data={previewData} /><button onClick={handleExport} className="btn mt-1" style={{ backgroundColor: 'var(--success-color)', color: 'white' }}>Télécharger en CSV</button></>)}
            </div>
        </div>
    );
}

function ComboBoxFilter({ name, placeholder, options, getOptionValue, getOptionLabel, onChange }) {
    const dataListId = `datalist-${name}-${Math.random()}`;
    return (
        <div className="form-group" style={{ flex: 1, marginBottom: 0 }}>
            <input list={dataListId} name={name} placeholder={placeholder} onChange={(e) => onChange(name, e.target.value)} className="form-input" autoComplete="off" />
            <datalist id={dataListId}>
                <option value="">-- Aucun --</option>
                {options.map(option => (<option key={getOptionValue(option)} value={getOptionValue(option)}>{getOptionLabel(option)}</option>))}
            </datalist>
        </div>
    );
}

function PreviewTable({ data }) {
    if (!data || data.length === 0) return <p className="mt-2 text-center info-message">Aucune donnée à prévisualiser pour les filtres sélectionnés.</p>;
    const headers = Object.keys(data[0]);
    return (<div className="mt-2"><h3 className="mb-1">Aperçu des Données</h3><div className="table-container"><table className="table"><thead><tr>{headers.map(h => <th key={h}>{columnTranslations[h] || h.replace(/_/g, ' ')}</th>)}</tr></thead><tbody>{data.map((row, i) => <tr key={i}>{headers.map(h => <td key={h}>{String(row[h])}</td>)}</tr>)}</tbody></table></div></div>);
}

# --------------- END OF FILE: frontend/src/App.jsx ---------------

